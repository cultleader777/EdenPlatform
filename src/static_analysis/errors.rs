use std::collections::BTreeMap;

#[derive(PartialEq, Eq, Debug)]
pub enum PlatformValidationError {
    InvalidNetworkIpV4Subnet {
        network_name: String,
        subnet_value: String,
        parsing_error: String,
    },
    InvalidDcIpV4Subnet {
        datacenter_name: String,
        subnet_value: String,
        parsing_error: String,
    },
    NetworkSubnetIsNotTruncated {
        network_name: String,
        subnet_value: String,
        expected_value: String,
    },
    NetworkLanDisallowedSubnetValue {
        network_name: String,
        subnet_value: String,
        only_allowed_value: String,
    },
    NetworkVpnDisallowedSubnetValue {
        network_name: String,
        subnet_value: String,
        only_allowed_value: String,
    },
    NetworkDcrouterDisallowedSubnetValue {
        network_name: String,
        subnet_value: String,
        only_allowed_value: String,
    },
    InvalidServerInterfaceName {
        server_name: String,
        interface_name: String,
        explanation: String,
    },
    InvalidServerSubinterfaceIndex {
        server_name: String,
        interface_name: String,
        explanation: String,
    },
    InvalidServerSubinterface {
        server_name: String,
        interface_name: String,
        explanation: String,
    },
    InvalidServerSubinterfaceBelongsToSameParentNetwork {
        server_name: String,
        interface_name: String,
        parent_network: String,
        parent_network_cidr: String,
        subinterface_network: String,
        subinterface_network_cidr: String,
        explanation: String,
    },
    InvalidServerSubinterfaceOnlyCoprocessorDcAllowsSubinterface {
        server_name: String,
        interface_name: String,
        datacenter: String,
        datacenter_implementation: String,
        only_allowed_datacenter_implementation: String,
    },
    InvalidIpV4Address {
        server_name: String,
        interface_name: String,
        value: String,
        parsing_error: String,
    },
    InternetNetworkCannotHavePrivateIpAddresses {
        server_name: String,
        interface_name: String,
        network_name: String,
        ip_address: String,
        forbidden_ranges: Vec<String>,
    },
    NonInternetNetworkCannotHavePublicIpAddresses {
        server_name: String,
        interface_name: String,
        network_name: String,
        ip_address: String,
        allowed_ranges: Vec<String>,
    },
    InterfaceIpIsNotInsideSubnet {
        server_name: String,
        interface_name: String,
        interface_ip: String,
        network_name: String,
        subnet_range: String,
    },
    FirstIpInSubnetIsReservedToGateway {
        server_name: String,
        interface_name: String,
        interface_ip: String,
        network_name: String,
        subnet_range: String,
    },
    ServerIpCannotBeNetworkAddress {
        server_name: String,
        interface_name: String,
        interface_ip: String,
        network_name: String,
        subnet_range: String,
    },
    ServerIpCannotBeBroadcastAddress {
        server_name: String,
        interface_name: String,
        interface_ip: String,
        network_name: String,
        subnet_range: String,
    },
    DuplicateIpFoundOnTheNetwork {
        server_a_name: String,
        interface_a_name: String,
        interface_a_ip: String,
        server_b_name: String,
        interface_b_name: String,
        interface_b_ip: String,
        subnet_name: String,
        subnet_range: String,
    },
    SubnetOverlapAcrossInterfaces {
        server_a_name: String,
        interface_a_name: String,
        interface_a_ip: String,
        server_b_name: String,
        interface_b_name: String,
        interface_b_ip: String,
        subnet_name: String,
        subnet_range: String,
    },
    SubnetOverlapAcrossNetworks {
        network_a_name: String,
        network_a_cidr: String,
        network_b_name: String,
        network_b_cidr: String,
    },
    InvalidPublicIpV6AddressForNode {
        server_name: String,
        ipv6_address: String,
        parsing_error: String,
    },
    PublicIpV6AddressForNodeIsLoopback {
        server_name: String,
        ipv6_address: String,
    },
    PublicIpV6AddressForNodeIsMulticast {
        server_name: String,
        ipv6_address: String,
    },
    PublicIpV6AddressIsPrivate {
        server_name: String,
        ipv6_address: String,
    },
    ServerHasPublicIpV6AddressButDoesntHaveIpV4PublicAddress {
        server_name: String,
        ipv6_address: String,
        ipv4_network_interfaces: Vec<String>,
    },
    DatacenterLanNetworkMustHaveSlash16Prefix {
        datacenter_name: String,
        network_cidr: String,
        expected_prefix: String,
        actual_prefix: String,
    },
    DatacenterNetworkDoesntBelongToGlobalLan {
        network_name: String,
        network_cidr: String,
        datacenter_name: String,
        datacenter_cidr: String,
    },
    DatacenterNetworkClash {
        datacenter_a_name: String,
        datacenter_a_network_cidr: String,
        datacenter_b_name: String,
        datacenter_b_network_cidr: String,
    },
    LanInterfaceCidrIsNot24 {
        server_name: String,
        interface_network: String,
        interface_name: String,
        interface_ip: String,
        interface_cidr: i64,
        expected_cidr: i64,
    },
    LanInterfaceCidrIsNot32 {
        server_name: String,
        interface_network: String,
        interface_name: String,
        interface_ip: String,
        interface_cidr: i64,
        expected_cidr: i64,
        datacenter_implementation: String,
    },
    LanInterfaceIsInsideForbiddenDcrouterRange {
        server_name: String,
        interface_network: String,
        interface_name: String,
        interface_ip: String,
        interface_cidr: i64,
        dcrouter_range: String,
    },
    DcrouterInterfaceIsOutsideAllowedRange {
        server_name: String,
        interface_network: String,
        interface_name: String,
        interface_ip: String,
        interface_cidr: i64,
        dcrouter_range: String,
    },
    DcrouterInterfaceCidrIsNot22 {
        server_name: String,
        interface_network: String,
        interface_name: String,
        interface_ip: String,
        interface_cidr: i64,
        expected_cidr: i64,
    },
    VpnInterfaceCidrIsNot16 {
        server_name: String,
        interface_network: String,
        interface_name: String,
        interface_ip: String,
        interface_cidr: i64,
        expected_cidr: i64,
    },
    InterfaceIpIsNotInsideDatacenterSubnet {
        server_name: String,
        interface_name: String,
        interface_ip: String,
        interface_network: String,
        datacenter_name: String,
        datacenter_subnet: String,
    },
    InterfaceIpThirdOctetIsTooLarge {
        server_name: String,
        interface_name: String,
        interface_ip: String,
        interface_network: String,
        datacenter_name: String,
        datacenter_subnet: String,
        explanation: String,
    },
    DcrouterDuplicateRouterIpInsideDatacenterDetected {
        datacenter: String,
        previous_server_hostname: String,
        previous_server_interface_ip: String,
        duplicate_server_hostname: String,
        duplicate_server_interface_ip: String,
    },
    RuntimeError {
        error: String,
    },
    PgRuntimeError {
        database: String,
        error: String,
    },
    // db migrations must be defined in order in edendb
    PgMigrationsAreNotOrdered {
        previous_migration_time: i64,
        current_migration_time: i64,
        previous_migration: String,
        current_migration: String,
    },
    PgMigrationUpgradeError {
        pg_schema: String,
        upgrade_sql: String,
        upgrade_time: i64,
        error: String,
    },
    PgMigrationDowngradeError {
        database: String,
        downgrade_sql: String,
        upgrade_time: i64,
        error: String,
    },
    PgMigrationInconsistentDowngrade {
        database: String,
        upgrade_sql: String,
        downgrade_sql: String,
        upgrade_time: i64,
        schema_diff: String,
    },
    PgNullableColumnsAreNotAllowed {
        table_name: String,
        table_column_name: String,
        table_column_type: String,
        migration_sql: String,
    },
    PgOriginalQueryParametersAreNotAllowed {
        query_expression: String,
        found_forbidden_value: String,
    },
    PgUnsupportedArgumentType {
        query_expression: String,
        unsupported_type: String,
        allowed_types: Vec<&'static str>,
    },
    PgDivergingTypesForSameArgument {
        query_expression: String,
        argument_name: String,
        type_a: String,
        type_b: String,
    },
    PgArgumentTypeUnspecifiedAtLeastOnce {
        query_expression: String,
        argument_name: String,
    },
    PgQueryParsingError {
        query_expression: String,
        syntax_error: String,
    },
    PgCantDeserializeTestDataset {
        pg_schema: String,
        error: String,
        input_dataset_name: String,
        input_data: String,
    },
    PgCantParseTestArguments {
        input_data: String,
        error: String,
    },
    PgCantParseTestOutputs {
        input_data: String,
        error: String,
    },
    PgDatasetTableNotFoundInSchema {
        pg_schema: String,
        table_tried_to_insert: String,
        input_dataset_name: String,
    },
    PgDatasetTableColumnNotFoundInSchema {
        pg_schema: String,
        table: String,
        table_column_tried_to_insert: String,
        input_dataset_name: String,
    },
    PgDatasetColumnValueCannotBeParsedToExpectedType {
        pg_schema: String,
        table: String,
        column: String,
        column_value: String,
        type_tried_to_parse_to: String,
        parsing_error: String,
        input_dataset_name: String,
    },
    PgDatasetColumnValueInvalidBoolean {
        pg_schema: String,
        table: String,
        column: String,
        column_value: String,
        accepted_true_values: &'static str,
        accepted_false_values: &'static str,
    },
    PgDatasetUnsupportedColumnType {
        database: String,
        table: String,
        column: String,
        column_value: String,
        column_type: String,
        input_dataset_name: String,
    },
    PgDatasetIsNeverTested {
        pg_schema: String,
        input_dataset_name: String,
        minimum_dataset_time: i64,
        maximum_migration_time: i64,
    },
    PgErrorInsertingTestDataset {
        error: String,
        insert_sql: String,
        insert_values: String,
        test_dataset_name: String,
    },
    PgQueryError {
        pg_schema: String,
        query_name: String,
        original_query: String,
        interpolated_query: String,
        query_arguments: String,
        error: String,
    },
    PgMutatorError {
        pg_schema: String,
        mutator_name: String,
        original_query: String,
        interpolated_query: String,
        query_arguments: String,
        error: String,
    },
    PgQueryErrorEmptyRowSet {
        pg_schema: String,
        query_name: String,
        original_query: String,
        interpolated_query: String,
        query_arguments: String,
        test_dataset_name: String,
    },
    PgMutatorCannotChangeDbSchema {
        pg_schema: String,
        mutator_name: String,
        original_query: String,
    },
    PgMutatorDidNotModifyDatabase {
        pg_schema: String,
        mutator_name: String,
        original_query: String,
        interpolated_query: String,
        query_arguments: String,
        test_dataset_name: String,
    },
    PgMutatingQueryDidNotModifyDatabase {
        pg_schema: String,
        query_name: String,
        original_query: String,
        interpolated_query: String,
        query_arguments: String,
        test_dataset_name: String,
    },
    PgQueryTimeoutError {
        limit_ms: u64,
        pg_schema: String,
        query_name: String,
        original_query: String,
        interpolated_query: String,
        query_arguments: String,
    },
    PgMutatorTimeoutError {
        limit_ms: u64,
        pg_schema: String,
        mutator_name: String,
        original_query: String,
        interpolated_query: String,
        query_arguments: String,
    },
    PgQueryInvalidOutputFieldNameFormat {
        pg_schema: String,
        query_name: String,
        original_query: String,
        interpolated_query: String,
        query_arguments: String,
        output_field_index: usize,
        output_field_name: String,
        output_field_type: String,
        expectation: &'static str,
    },
    PgQueryUnsupportedTypeError {
        pg_schema: String,
        query_name: String,
        original_query: String,
        interpolated_query: String,
        query_arguments: String,
        output_field_index: usize,
        output_field_name: String,
        output_field_type: String,
    },
    PgQueryDuplicateOutputFieldNames {
        pg_schema: String,
        query_name: String,
        original_query: String,
        interpolated_query: String,
        query_arguments: String,
        output_field_name: String,
    },
    PgQueryUnexpectedOutputs {
        pg_schema: String,
        query_name: String,
        original_query: String,
        interpolated_query: String,
        query_arguments: String,
        expected_outputs: String,
        actual_outputs: String,
    },
    PgQueryCannotMutateDatabase {
        pg_schema: String,
        query_name: String,
        original_query: String,
    },
    PgMutatingQueryDoesNotHaveMutationKeywords {
        pg_schema: String,
        query_name: String,
        original_query: String,
        expected_keywords: Vec<&'static str>,
    },
    PgQueryHasNoTests {
        pg_schema: String,
        query_name: String,
        original_query: String,
    },
    PgMutatorHasNoTests {
        pg_schema: String,
        mutator_name: String,
        original_query: String,
    },
    PgMaterializedViewHasNoTests {
        pg_schema: String,
        materialized_view_name: String,
    },
    PgQueryArgumentNotFoundInTest {
        database: String,
        query_name: String,
        query_expression: String,
        arguments: String,
        argument_not_found: String,
    },
    PgQueryArgumentNotUsedInQuery {
        pg_schema: String,
        query_name: String,
        query_expression: String,
        arguments: String,
        argument_not_used: String,
    },
    PgQueryCannotParseArgumentToType {
        database: String,
        query_name: String,
        query_expression: String,
        arguments: String,
        argument_name: String,
        argument_value: String,
        argument_expected_type: String,
        parsing_error: String,
    },
    PgQuerySequentialScansFound {
        pg_schema: String,
        original_query: String,
        interpolated_query: String,
        query_name: String,
        query_arguments: String,
        seq_scan_table: String,
        query_plan: String,
    },
    PgQueryAndMutatorShareSameName {
        pg_schema: String,
        query_or_mutator_name: String,
    },
    PgQueryOptFieldMustBeSnakeCase {
        pg_schema: String,
        query_name: String,
        bad_optional_field: String,
        optional_fields: String,
    },
    PgQueryOptFieldDuplicate {
        pg_schema: String,
        query_name: String,
        duplicate_optional_field: String,
        optional_fields: String,
    },
    PgQueryOptFieldDoesntExistInQueryResults {
        pg_schema: String,
        query_name: String,
        bad_optional_field: String,
        optional_fields: String,
        original_query: String,
    },
    PgTransactionStepNotFound {
        pg_schema: String,
        transaction_name: String,
        step_not_found: String,
    },
    PgTransactionMustHaveAtLeastTwoSteps {
        pg_schema: String,
        transaction_name: String,
        step_count: usize,
    },
    PgTransactionWithoutMutatorsMustBeMarkedAsReadOnly {
        pg_schema: String,
        transaction_name: String,
    },
    PgTransactionReadOnlyTransactionHasMutators {
        pg_schema: String,
        transaction_name: String,
    },
    PgTransactionDuplicateStepsDetected {
        pg_schema: String,
        transaction_name: String,
        duplicate_step_name: String,
    },
    PgMaterializedViewWasNotCreatedInMigrations {
        database: String,
        materialized_view: String,
        migration_time: i64,
    },
    PgMaterializedViewExpectedOutputColumnNotFound {
        pg_schema: String,
        materialized_view: String,
        expected_dataset_column: String,
        actual_materialized_view_columns: Vec<String>,
        expected_results: String,
    },
    PgMaterializedViewExpectedOutputIsMissingActualColumn {
        pg_schema: String,
        materialized_view: String,
        missing_column_in_expected_row: String,
        actual_materialized_view_columns: Vec<String>,
        expected_results: String,
    },
    PgMaterializedViewTestOutputRowCountMistmatch {
        pg_schema: String,
        materialized_view: String,
        expected_materialized_view_rows_count: usize,
        actual_materialized_view_rows_count: usize,
        expected_results: String,
    },
    PgMaterializedViewSortedOutputRowsMismatch {
        pg_schema: String,
        materialized_view: String,
        diff: String,
    },
    PgReservedTableName {
        pg_schema: String,
        table_name: String,
        upgrade_sql: String,
        upgrade_time: i64,
    },
    PgDeploymentDuplicateDatabases {
        pg_deployment: String,
        db_name_a: String,
        db_name_b: String,
    },
    PgDeploymentMonitoringClusterDoesntExistInRegion {
        pg_deployment: String,
        db_region: String,
        not_found_monitoring_cluster: String,
        available_monitoring_clusters: Vec<String>,
    },
    PgDeploymentLoggingClusterDoesntExistInRegion {
        pg_deployment: String,
        db_region: String,
        not_found_loki_cluster: String,
        available_loki_clusters: Vec<String>,
    },
    PgDeploymentInstanceIsOutsideSpecifiedRegion {
        pg_deployment: String,
        db_region: String,
        server: String,
        server_region: String,
    },
    PgDeploymentMustHaveAtLeastTwoNodes {
        pg_deployment: String,
        db_region: String,
        found_instances: usize,
        minimum_instances: usize,
    },
    PgDeploymentForSynchronousReplicationYouMustRunAtLeastThreeNodes {
        pg_deployment: String,
        db_region: String,
        synchronous_replication_enabled: bool,
        found_instances: usize,
        minimum_instances: usize,
    },
    PgDeploymentHasMoreThanMaximumChildInstancesAllowed {
        pg_deployment: String,
        db_region: String,
        found_instances: usize,
        maximum_instances: usize,
    },
    PgTableNameIsNotSnakeCase {
        migration_sql: String,
        bad_table_name: String,
    },
    PgColumnNameIsNotSnakeCase {
        migration_sql: String,
        table_name: String,
        bad_column_name: String,
    },
    PgWhitespaceForbiddenInQueryArguments {
        query: String,
        bad_argument: String,
        found_whitespace: usize,
        expected_whitespace: usize,
    },
    PgResultingDatasetForMutatorTestIsUndefined {
        pg_schema: String,
        mutator_name: String,
        resulting_data: String,
        pg_mutator_test_arguments: String,
    },
    PgCantDeserializeMutatorResultingData {
        pg_schema: String,
        error: String,
        mutator_name: String,
        mutator_test_data: String,
    },
    PgResultingDatasetTableRowIsEmpty {
        pg_schema: String,
        mutator_name: String,
        resulting_data_table: String,
        resulting_data: String,
    },
    PgResultingDatasetTableColumnDoesntExist {
        pg_schema: String,
        mutator_name: String,
        resulting_data_table: String,
        resulting_data_non_existing_column: String,
        resulting_data: String,
    },
    PgResultingDatasetColumnValueCannotBeParsedToExpectedType {
        pg_schema: String,
        mutator_name: String,
        resulting_data_table: String,
        resulting_data_column: String,
        resulting_data_column_value: String,
        resulting_data: String,
        type_tried_to_parse_to: String,
        parsing_error: String,
    },
    PgResultingDatasetUnsupportedColumnType {
        pg_schema: String,
        mutator_name: String,
        resulting_data_table: String,
        resulting_data_column: String,
        resulting_data_column_type: String,
        resulting_data_column_value: String,
        resulting_data: String,
    },
    PgResultingDatasetTableDoesntExist {
        pg_schema: String,
        mutator_name: String,
        resulting_data_non_existing_table: String,
        resulting_data: String,
    },
    PgResultingDatasetRowIsFoundInTestDatasetBeforeMutatorIsExecuted {
        pg_schema: String,
        mutator_name: String,
        resulting_data_table: String,
        row_found_before_mutator_execution: String,
        resulting_data: String,
    },
    PgResultingDatasetRowFoundMoreThanOnceInTable {
        pg_schema: String,
        mutator_name: String,
        resulting_data_table: String,
        resulting_data_ambigous_row: String,
        output_dataset_matching_rows: String,
        resulting_data: String,
    },
    PgResultingDatasetRowsAreNotFoundInTableAfterMutatorExecution {
        pg_schema: String,
        mutator_name: String,
        resulting_data_table: String,
        rows_not_found_after_mutator_execution: String,
        resulting_data: String,
    },
    ChQueryHasNoTests {
        ch_schema: String,
        query_name: String,
        original_query: String,
    },
    ChMutatorHasNoTests {
        ch_schema: String,
        mutator_name: String,
        mutator_expression: String,
    },
    ChMigrationsAreNotOrdered {
        previous_migration_time: i64,
        current_migration_time: i64,
        previous_migration: String,
        current_migration: String,
    },
    ChMigrationUpgradeError {
        ch_schema: String,
        upgrade_sql: String,
        upgrade_time: i64,
        error: String,
    },
    ChReservedTableName {
        ch_schema: String,
        table_name: String,
        upgrade_sql: String,
        upgrade_time: i64,
    },
    ChDatasetIsNeverTested {
        ch_schema: String,
        input_dataset_name: String,
        minimum_dataset_time: i64,
        maximum_migration_time: i64,
    },
    ChDatasetTableNotFoundInSchema {
        ch_schema: String,
        table_tried_to_insert: String,
        input_dataset_name: String,
    },
    ChDatasetTableColumnNotFoundInSchema {
        ch_schema: String,
        table: String,
        table_column_tried_to_insert: String,
        input_dataset_name: String,
    },
    ChDatasetTableColumnIsNotAllowedToBeInserted {
        ch_schema: String,
        table: String,
        table_column_tried_to_insert: String,
        input_dataset_name: String,
        explanation: String,
    },
    ChDatasetColumnValueCannotBeParsedToExpectedType {
        ch_schema: String,
        table: String,
        column: String,
        column_value: String,
        type_tried_to_parse_to: String,
        parsing_error: String,
        input_dataset_name: String,
    },
    ChDatasetUnsupportedColumnType {
        database: String,
        table: String,
        column: String,
        column_value: String,
        column_type: String,
        input_dataset_name: String,
    },
    ChErrorInsertingTestDataset {
        error: String,
        insert_sql: String,
        insert_values: String,
        test_dataset_name: String,
    },
    ChDatasetColumnValueInvalidBoolean {
        ch_schema: String,
        table: String,
        column: String,
        column_value: String,
        accepted_true_values: &'static str,
        accepted_false_values: &'static str,
    },
    ChMigrationDowngradeError {
        database: String,
        downgrade_sql: String,
        upgrade_time: i64,
        error: String,
    },
    ChMigrationInconsistentDowngrade {
        database: String,
        upgrade_sql: String,
        downgrade_sql: String,
        upgrade_time: i64,
        schema_diff: String,
    },
    ChMigrationUnsupportedTableEngine {
        database: String,
        migration_sql: String,
        table_engine: String,
        supported_table_engines: Vec<String>,
    },
    ChMigrationUseUnreplicatedMergeTreesInEpl {
        database: String,
        migration_sql: String,
        table_engine: String,
        expected_table_engine: String,
        explanation: String,
    },
    ChMigrationCreateTableMustHaveIfNotExistsStatement {
        database: String,
        migration_sql: String,
        expected_create_table_statement: String,
    },
    ChMigrationCreateViewMustHaveIfNotExistsStatement {
        database: String,
        migration_sql: String,
        expected_create_view_statement: String,
    },
    ChMigrationCreateMaterializedViewMustHaveIfNotExistsStatement {
        database: String,
        migration_sql: String,
        expected_create_materialized_view_statement: String,
    },
    ChMigrationDropTableMustHaveIfExistsStatement {
        database: String,
        migration_sql: String,
        expected_drop_table_statement: String,
    },
    ChMigrationDropViewMustHaveIfExistsStatement {
        database: String,
        migration_sql: String,
        expected_drop_view_statement: String,
    },
    ChMigrationDoesntSupportRenamesOrExchanges {
        database: String,
        migration_sql: String,
        unsupported_statements: Vec<String>,
    },
    ChSchemaHasDuplicateQueriesOrMutators {
        ch_schema: String,
        query_name: String,
        mutator_with_same_name: String,
    },
    ChQueryError {
        ch_schema: String,
        query_name: String,
        original_query: String,
        interpolated_query: String,
        query_arguments: String,
        error: String,
    },
    ChMutatorError {
        ch_schema: String,
        mutator_name: String,
        original_query: String,
        interpolated_query: String,
        query_arguments: String,
        error: String,
    },
    ChMutatorCannotReturnAnyRows {
        ch_schema: String,
        mutator_name: String,
        original_query: String,
        interpolated_query: String,
        query_arguments: String,
        returned_rows_count: usize,
        returned_rows: Vec<Vec<String>>,
    },
    ChCantDeserializeMutatorResultingData {
        ch_schema: String,
        error: String,
        mutator_name: String,
        mutator_test_data: String,
    },
    ChResultingDatasetTableDoesntExist {
        ch_schema: String,
        mutator_name: String,
        resulting_data_non_existing_table: String,
        resulting_data: String,
    },
    ChResultingDatasetForMutatorTestIsUndefined {
        ch_schema: String,
        mutator_name: String,
        resulting_data: String,
        ch_mutator_test_arguments: String,
    },
    ChResultingDatasetTableRowIsEmpty {
        ch_schema: String,
        mutator_name: String,
        resulting_data_table: String,
        resulting_data: String,
    },
    ChResultingDatasetRowFoundMoreThanOnceInTable {
        ch_schema: String,
        mutator_name: String,
        resulting_data_table: String,
        resulting_data_ambigous_row: String,
        output_dataset_matching_rows: String,
        resulting_data: String,
    },
    ChResultingDatasetRowIsFoundInTestDatasetBeforeMutatorIsExecuted {
        ch_schema: String,
        mutator_name: String,
        resulting_data_table: String,
        row_found_before_mutator_execution: String,
        resulting_data: String,
    },
    ChResultingDatasetRowsAreNotFoundInTableAfterMutatorExecution {
        ch_schema: String,
        mutator_name: String,
        resulting_data_table: String,
        rows_not_found_after_mutator_execution: String,
        resulting_data: String,
    },
    ChResultingDatasetTableColumnDoesntExist {
        ch_schema: String,
        mutator_name: String,
        resulting_data_table: String,
        resulting_data_non_existing_column: String,
        resulting_data: String,
    },
    ChResultingDatasetColumnValueCannotBeParsedToExpectedType {
        ch_schema: String,
        mutator_name: String,
        resulting_data_table: String,
        resulting_data_column: String,
        resulting_data_column_value: String,
        type_tried_to_parse_to: String,
        parsing_error: String,
        resulting_data: String,
    },
    ChResultingDatasetUnsupportedColumnType {
        ch_schema: String,
        mutator_name: String,
        resulting_data_table: String,
        resulting_data_column: String,
        resulting_data_column_type: String,
        resulting_data_column_value: String,
        resulting_data: String,
    },
    ChQueryErrorEmptyRowSet {
        ch_schema: String,
        query_name: String,
        original_query: String,
        interpolated_query: String,
        query_arguments: String,
        test_dataset_name: String,
    },
    ChQueryOptFieldDoesntExistInQueryResults {
        ch_schema: String,
        query_name: String,
        bad_optional_field: String,
        optional_fields: String,
        original_query: String,
    },
    ChQueryInvalidOutputFieldNameFormat {
        ch_schema: String,
        query_name: String,
        original_query: String,
        interpolated_query: String,
        query_arguments: String,
        output_field_index: usize,
        output_field_name: String,
        output_field_type: String,
        expectation: &'static str,
    },
    ChQueryUnsupportedTypeError {
        ch_schema: String,
        query_name: String,
        original_query: String,
        interpolated_query: String,
        query_arguments: String,
        output_field_index: usize,
        output_field_name: String,
        output_field_type: String,
    },
    ChQueryDuplicateOutputFieldNames {
        ch_schema: String,
        query_name: String,
        original_query: String,
        interpolated_query: String,
        query_arguments: String,
        output_field_name: String,
    },
    ChQueryUnexpectedOutputs {
        ch_schema: String,
        query_name: String,
        original_query: String,
        interpolated_query: String,
        query_arguments: String,
        expected_outputs: String,
        actual_outputs: String,
    },
    ChQueryOptFieldMustBeSnakeCase {
        ch_schema: String,
        query_name: String,
        bad_optional_field: String,
        optional_fields: String,
    },
    ChQueryOptFieldDuplicate {
        ch_schema: String,
        query_name: String,
        duplicate_optional_field: String,
        optional_fields: String,
    },
    ChQueryCannotParseArgumentToType {
        database: String,
        query_name: String,
        query_expression: String,
        arguments: String,
        argument_name: String,
        argument_value: String,
        argument_expected_type: String,
        parsing_error: String,
    },
    ChQueryArgumentNotFoundInTest {
        database: String,
        query_name: String,
        query_expression: String,
        arguments: String,
        argument_not_found: String,
    },
    ChQueryArgumentNotUsedInQuery {
        ch_schema: String,
        query_name: String,
        query_expression: String,
        arguments: String,
        argument_not_used: String,
    },
    ChUnsupportedArgumentType {
        query_expression: String,
        unsupported_type: String,
        allowed_types: Vec<&'static str>,
    },
    ChDivergingTypesForSameArgument {
        query_expression: String,
        argument_name: String,
        type_a: String,
        type_b: String,
    },
    ChArgumentTypeUnspecifiedAtLeastOnce {
        query_expression: String,
        argument_name: String,
    },
    ChOriginalQueryParametersAreNotAllowed {
        query_expression: String,
        found_forbidden_value: String,
    },
    ChQueryParsingError {
        query_expression: String,
        syntax_error: String,
    },
    ChCantDeserializeTestDataset {
        ch_schema: String,
        error: String,
        input_dataset_name: String,
        input_data: String,
    },
    ChCantParseTestArguments {
        input_data: String,
        error: String,
    },
    ChCantParseTestOutputs {
        input_data: String,
        error: String,
    },
    ChMigrationContainsBacktick {
        input_sql: String,
        forbidden_character: String,
    },
    ChTableNameIsNotSnakeCase {
        migration_sql: String,
        bad_table_name: String,
    },
    ChColumnNameIsNotSnakeCase {
        migration_sql: String,
        table_name: String,
        bad_column_name: String,
    },
    ChColumnNullableValuesNotAllowed {
        migration_sql: String,
        table_name: String,
        column_name: String,
        column_type: String,
    },
    ChTableForbiddenPrefix {
        migration_sql: String,
        table_name: String,
        forbidden_prefix: String,
    },
    ChWhitespaceForbiddenInQueryArguments {
        query: String,
        bad_argument: String,
        found_whitespace: usize,
        expected_whitespace: usize,
    },
    ChNatsStreamAndChDeploymentAreInDifferentRegions {
        ch_deployment: String,
        ch_deployment_region: String,
        nats_jetstream_stream: String,
        nats_cluster: String,
        nats_cluster_region: String,
    },
    ChNatsStreamIntoTableDoesntExist {
        ch_nats_stream_import_consumer_name: String,
        ch_deployment: String,
        ch_database: String,
        ch_schema: String,
        into_table: String,
        existing_tables: Vec<String>,
    },
    ChNatsStreamIntoTableColumnDoesntExist {
        ch_nats_stream_import_consumer_name: String,
        ch_deployment: String,
        ch_database: String,
        ch_schema: String,
        into_table: String,
        bw_compat_type: String,
        bw_compat_non_existing_field_name: String,
        existing_columns_in_table: Vec<String>,
    },
    ChNatsStreamUnsupportedFieldType {
        ch_nats_stream_import_consumer_name: String,
        ch_deployment: String,
        ch_database: String,
        ch_schema: String,
        into_table: String,
        nats_jetstream_stream: String,
        bw_compat_type: String,
        bw_compat_unsupported_field_name: String,
        bw_compat_unsupported_field_type: String,
        message: String,
    },
    ChNatsStreamIntoTableColumnTypeMismatch {
        ch_nats_stream_import_consumer_name: String,
        ch_deployment: String,
        ch_database: String,
        ch_schema: String,
        into_table: String,
        nats_jetstream_stream: String,
        bw_compat_type: String,
        bw_compat_type_field_name: String,
        bw_compat_type_field_type: String,
        table_column_type: String,
    },
    ChNatsStreamHasEnableSubjectsWhichIsUnsupported {
        ch_nats_stream_import_consumer_name: String,
        ch_deployment: String,
        ch_database: String,
        ch_schema: String,
        into_table: String,
        nats_jetstream_stream: String,
        nats_jetstream_stream_enable_subjects: bool,
    },
    ChNatsStreamIntoTableColumnFieldIsNotAllowedToBeInserted {
        ch_nats_stream_import_consumer_name: String,
        ch_deployment: String,
        ch_database: String,
        ch_schema: String,
        into_table: String,
        nats_jetstream_stream: String,
        bw_compat_type: String,
        bw_compat_type_field_name: String,
        table_column_type: String,
        explanation: String,
    },
    ChNatsStreamIntoTableColumnFieldHasNoDefaultAndDoesntExistInBwType {
        ch_nats_stream_import_consumer_name: String,
        ch_deployment: String,
        ch_database: String,
        ch_schema: String,
        into_table: String,
        nats_jetstream_stream: String,
        bw_compat_type: String,
        table_column_type: String,
        missing_table_column_from_nats: String,
        explanation: String,
    },
    ApplicationMonitoringClusterDoesntExistInRegion {
        application_deployment: String,
        application_name: String,
        application_region: String,
        not_found_monitoring_cluster: String,
        available_monitoring_clusters: Vec<String>,
    },
    ApplicationLoggingClusterDoesntExistInRegion {
        application_deployment: String,
        application_name: String,
        application_region: String,
        not_found_loki_cluster: String,
        available_loki_clusters: Vec<String>,
    },
    ApplicationTracingClusterDoesntExistInRegion {
        application_deployment: String,
        application_name: String,
        application_region: String,
        not_found_tempo_cluster: String,
        available_tempo_clusters: Vec<String>,
    },
    ApplicationPgShardQueryNotFoundInPgSchema {
        queries_src: String,
        query_not_found: String,
        application_pg_schema: String,
        application_pg_shard: String,
        application: String,
    },
    ApplicationPgShardMutatorNotFoundInPgSchema {
        mutators_src: String,
        mutator_not_found: String,
        application_pg_schema: String,
        application_pg_shard: String,
        application: String,
    },
    ApplicationPgShardTransactionNotFoundInPgSchema {
        transactions_src: String,
        transaction_not_found: String,
        application_pg_schema: String,
        application_pg_shard: String,
        application: String,
    },
    ApplicationPgShardQueryDefinedTwice {
        used_queries_src: String,
        used_query_defined_twice: String,
        application_pg_schema: String,
        application_pg_shard: String,
        application: String,
    },
    ApplicationPgShardMutatorDefinedTwice {
        used_mutators_src: String,
        used_mutator_defined_twice: String,
        application_pg_schema: String,
        application_pg_shard: String,
        application: String,
    },
    ApplicationPgShardTransactionDefinedTwice {
        used_transactions_src: String,
        used_transaction_defined_twice: String,
        application_pg_schema: String,
        application_pg_shard: String,
        application: String,
    },
    ApplicationPgWiringInvalidFormat {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        explanation: &'static str,
    },
    ApplicationPgWiringApplicationHasNoDbShards {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        explanation: &'static str,
    },
    ApplicationPgWiringApplicationHasNoDbShard {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        missing_application_db_shard: String,
        valid_app_db_shards: Vec<String>,
        explanation: &'static str,
    },
    ApplicationPgWiringTargetDbDeploymentDoesntExist {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        missing_pg_deployment: String,
        explanation: &'static str,
    },
    ApplicationPgWiringApplicationShardDefinedMultipleTimes {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        redefined_app_db_shard_name: String,
        explanation: &'static str,
    },
    ApplicationPgWiringUndefinedAppDbShard {
        application_deployment: String,
        application_name: String,
        undefined_application_db_shard: String,
        explanation: &'static str,
    },
    ApplicationPgWiringSchemaMismatch {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        application_expected_pg_schema: String,
        target_deployment_pg_schema: String,
        explanation: &'static str,
    },
    ApplicationPgWiringDifferentAppShardsPointToSameDatabase {
        application_deployment: String,
        application_name: String,
        app_shard_a_name: String,
        app_shard_b_name: String,
        target_physical_db_a: String,
        target_physical_db_b: String,
        explanation: &'static str,
    },
    ApplicationPgWiringDatabaseIsInDifferentRegion {
        application_deployment: String,
        application_name: String,
        application_region: String,
        application_db_name: String,
        application_db_wired_deployment: String,
        application_db_wired_region: String,
    },
    ApplicationChShardQueryNotFoundInChSchema {
        query_not_found: String,
        application_ch_schema: String,
        application_ch_shard: String,
        application: String,
    },
    ApplicationChShardQueryDefinedTwice {
        used_queries_src: String,
        used_query_defined_twice: String,
        application_ch_schema: String,
        application_ch_shard: String,
        application: String,
    },
    ApplicationChShardMutatorNotFoundInChSchema {
        mutator_not_found: String,
        application_ch_schema: String,
        application_ch_shard: String,
        application: String,
    },
    ApplicationChShardMutatorDefinedTwice {
        used_mutators_src: String,
        used_mutator_defined_twice: String,
        application_ch_schema: String,
        application_ch_shard: String,
        application: String,
    },
    ApplicationChShardInserterDefinedTwice {
        inserters_src: String,
        inserter_defined_twice: String,
        application_ch_schema: String,
        application_ch_shard: String,
        application: String,
    },
    ApplicationChShardInserterTableDoesntExist {
        application: String,
        non_existant_inserter_table: String,
        existing_tables_in_schema: Vec<String>,
    },
    ApplicationChShardInserterIntoViewIsNotAllowed {
        application: String,
        inserter_table: String,
        inserter_table_type: String,
    },
    ApplicationChShardInserterTableTypeNotSupported {
        application: String,
        inserter_table: String,
        inserter_table_column: String,
        inserter_table_column_type: String,
        supported_inserter_types: Vec<String>,
    },
    ApplicationChWiringInvalidFormat {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        explanation: &'static str,
    },
    ApplicationChWiringApplicationHasNoDbShards {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        explanation: &'static str,
    },
    ApplicationChWiringApplicationHasNoDbShard {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        missing_application_db_shard: String,
        valid_app_db_shards: Vec<String>,
        explanation: &'static str,
    },
    ApplicationChWiringTargetChDeploymentDoesntExist {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        missing_ch_deployment: String,
        explanation: &'static str,
    },
    ApplicationChWiringApplicationShardDefinedMultipleTimes {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        redefined_app_db_shard_name: String,
        explanation: &'static str,
    },
    ApplicationChWiringUndefinedAppDbShard {
        application_deployment: String,
        application_name: String,
        undefined_application_db_shard: String,
        explanation: &'static str,
    },
    ApplicationChWiringSchemaMismatch {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        application_expected_ch_schema: String,
        target_deployment_ch_schema: String,
        explanation: &'static str,
    },
    ApplicationChWiringDifferentAppShardsPointToSameDatabase {
        application_deployment: String,
        application_name: String,
        app_shard_a_name: String,
        app_shard_b_name: String,
        target_physical_db_a: String,
        target_physical_db_b: String,
        explanation: &'static str,
    },
    ApplicationChWiringDatabaseIsInDifferentRegion {
        application_deployment: String,
        application_name: String,
        application_region: String,
        application_db_name: String,
        application_db_wired_deployment: String,
        application_db_wired_region: String,
    },
    ApplicationS3BucketWiringIsInDifferentRegion {
        application_deployment: String,
        application_name: String,
        application_region: String,
        application_bucket_name: String,
        application_bucket_wired_minio_region: String,
        application_bucket_wired_minio_cluster: String,
        application_bucket_wired_minio_bucket: String,
    },
    ApplicationStreamsWiringInvalidFormat {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        explanation: &'static str,
    },
    ApplicationStreamsWiringUndefinedAppNatsStream {
        application_deployment: String,
        application_name: String,
        undefined_application_stream: String,
        explanation: &'static str,
    },
    ApplicationStreamsWiringApplicationHasNoStreams {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        explanation: &'static str,
    },
    ApplicationStreamsWiringApplicationHasNoStreamSpecified {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        missing_application_stream: String,
        valid_app_streams: Vec<String>,
        explanation: &'static str,
    },
    ApplicationStreamWiringTargetStreamDoesntExist {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        missing_nats_stream: String,
        explanation: &'static str,
    },
    ApplicationStreamWiringTypeMismatch {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        application_expected_stream_type: String,
        target_deployment_stream_type: String,
        explanation: &'static str,
    },
    ApplicationStreamWiringSubjectsEnabledMismatch {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        application_expected_enable_subjects: bool,
        target_deployment_stream_enable_subjects: bool,
        explanation: &'static str,
    },
    ApplicationStreamWiringApplicationStreamDefinedMultipleTimes {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        redefined_app_stream_name: String,
        explanation: &'static str,
    },
    ApplicationStreamWiringDifferentAppStreamsPointToSameNatsStream {
        application_deployment: String,
        application_name: String,
        app_stream_a_name: String,
        app_stream_b_name: String,
        target_physical_stream_a: String,
        target_physical_stream_b: String,
        explanation: &'static str,
    },
    ApplicationStreamWiringNatsClusterIsInDifferentRegion {
        application_deployment: String,
        application_name: String,
        application_region: String,
        application_nats_stream_name: String,
        application_nats_wired_cluster: String,
        application_nats_wired_region: String,
    },
    ApplicationBucketWiringApplicationBucketDefinedMultipleTimes {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        redefined_app_s3_bucket_name: String,
        explanation: &'static str,
    },
    ApplicationBucketWiringTargetBucketDoesntExist {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        missing_minio_bucket: String,
        explanation: &'static str,
    },
    ApplicationBucketsWiringApplicationHasNoBucketSpecified {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        missing_application_bucket: String,
        valid_app_buckets: Vec<String>,
        explanation: &'static str,
    },
    ApplicationBucketWiringInvalidFormat {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        explanation: &'static str,
    },
    ApplicationBucketWiringApplicationHasNoBuckets {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        explanation: &'static str,
    },
    ApplicationBucketWiringUndefinedAppBucket {
        application_deployment: String,
        application_name: String,
        undefined_application_bucket: String,
        explanation: &'static str,
    },
    ApplicationBucketWiringDifferentAppBucketsPointToSameMinioBucket {
        application_deployment: String,
        application_name: String,
        app_bucket_a_name: String,
        app_bucket_b_name: String,
        target_physical_bucket_a: String,
        target_physical_bucket_b: String,
        explanation: &'static str,
    },
    ApplicationConfigTypeCannotHaveRegexCheck {
        application_name: String,
        application_config: String,
        application_config_type: String,
        application_config_regex_check: String,
        application_config_regex_check_only_allowed_value: String,
    },
    ApplicationConfigInvalidRegexCheck {
        application_name: String,
        application_config: String,
        application_config_type: String,
        application_config_regex_check: String,
        regex_compilation_error: String,
    },
    ApplicationConfigTypeCannotHaveMinCheck {
        application_name: String,
        application_config: String,
        application_config_type: String,
        application_config_min_value: String,
    },
    ApplicationConfigTypeCannotParseMinValue {
        application_name: String,
        application_config: String,
        application_config_type: String,
        application_config_min_value: String,
        application_config_min_value_parsing_error: String,
    },
    ApplicationConfigTypeCannotHaveMaxCheck {
        application_name: String,
        application_config: String,
        application_config_type: String,
        application_config_max_value: String,
    },
    ApplicationConfigTypeCannotParseMaxValue {
        application_name: String,
        application_config: String,
        application_config_type: String,
        application_config_max_value: String,
        application_config_max_value_parsing_error: String,
    },
    ApplicationConfigTypeMinValueMustBeLessThanMaxValue {
        application_name: String,
        application_config: String,
        application_config_type: String,
        application_config_min_value: String,
        application_config_max_value: String,
    },
    ApplicationConfigInvalidDefaultValue {
        application_name: String,
        application_config: String,
        application_config_type: String,
        application_config_default_value: String,
        application_config_default_value_error: String,
    },
    ApplicationConfigDefinedMultipleTimesForDeployment {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        redefined_app_config: String,
        explanation: &'static str,
    },
    ApplicationConfigInvalidValue {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        bad_app_config: String,
        bad_app_config_type: String,
        error: String,
    },
    ApplicationConfigDoesntExist {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        missing_application_config: String,
        valid_app_configs: Vec<String>,
        explanation: &'static str,
    },
    ApplicationDoesntHaveAnyConfigs {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        explanation: &'static str,
    },
    ApplicationConfigInvalidFormat {
        application_deployment: String,
        application_name: String,
        bad_line: String,
        explanation: &'static str,
    },
    ApplicationConfigUndefinedAppConfig {
        application_deployment: String,
        application_name: String,
        undefined_application_config: String,
        explanation: &'static str,
    },
    BwTypeSnapshotSyntaxError {
        type_name: String,
        type_version: i64,
        syntax_error: String,
        snapshot_source: String,
    },
    BwTypeMigrationSyntaxError {
        type_name: String,
        type_version: i64,
        syntax_error: String,
        migration_source: String,
    },
    BwTypeSnapshotDuplicateFields {
        type_name: String,
        type_version: i64,
        duplicate_field_name: String,
    },
    BwTypeFieldIndexesMustBeZeroBasedSequential {
        type_name: String,
        type_version: i64,
        expected_field_index: u32,
        actual_field_index: u32,
        actual_field_index_name: String,
    },
    BwTypeMigrationAddsInvalidFieldIndex {
        type_name: String,
        type_version: i64,
        expected_field_index: u32,
        actual_field_index: u32,
        actual_field_index_name: String,
        migration_source: String,
    },
    BwTypeNoSnapshotsOrMigrationsFound {
        type_name: String,
    },
    BwTypeWithOneVersionCannotHaveAMigration {
        type_name: String,
        type_version: i64,
    },
    BwTypeFirstAndLastVersionMustHaveSnapshots {
        type_name: String,
        first_version: i64,
        last_version: i64,
        first_missing_snapshot: bool,
        last_missing_snapshot: bool,
    },
    BwTypeFirstVersionCantHaveMigration {
        type_name: String,
        first_version: i64,
    },
    BwTypeMigrationNotFoundForVersions {
        type_name: String,
        from_version: i64,
        to_version: i64,
    },
    BwTypeMigrationOptionAndDefaultValueAreMutuallyExclusive {
        type_name: String,
        to_version: i64,
        migration_source: String,
        field_path: Vec<String>,
    },
    BwTypeMigrationNewFieldMustHaveDefaultValueOrBeOptional {
        type_name: String,
        to_version: i64,
        migration_source: String,
        field_path: Vec<String>,
    },
    BwTypeSnapshotOptionAndDefaultValueAreMutuallyExclusive {
        type_name: String,
        version: i64,
        field_name: String,
    },
    BwTypeSnapshotDefaultValuesForTypeAreNotSupported {
        type_name: String,
        version: i64,
        the_type: String,
        field_name: String,
    },
    BwTypeSnapshotCannotParseDefaultValueForType {
        type_name: String,
        version: i64,
        the_type: String,
        default_value: String,
        parsing_error: String,
        field_name: String,
    },
    BwTypeSnapshotAndMigrationAreInconsistent {
        type_name: String,
        from_version: i64,
        to_version: i64,
        migration_source: String,
        expected_snapshot: String,
        actual_snapshot: String,
        pre_migration_snapshot: String,
    },
    BwTypeCannotAddDuplicateNameField {
        type_name: String,
        field_path: Vec<String>,
        from_version: i64,
        to_version: i64,
        migration_source: String,
        pre_migration_snapshot: String,
    },
    BwTypeExpectedStructTypeGotGround {
        type_name: String,
        field_path: Vec<String>,
        from_version: i64,
        to_version: i64,
        migration_source: String,
        pre_migration_snapshot: String,
    },
    BwTypeMigrationCannotFindFieldToDrop {
        type_name: String,
        field_path: Vec<String>,
        field_not_found: String,
        from_version: i64,
        to_version: i64,
        migration_source: String,
        pre_migration_snapshot: String,
    },
    BwTypeMigrationExpectedNestedStructFieldToDropGotGround {
        type_name: String,
        field_path: Vec<String>,
        from_version: i64,
        to_version: i64,
        migration_source: String,
        pre_migration_snapshot: String,
    },
    BwTypeMigrationStructBecomesEmptyAfterFieldDrop {
        type_name: String,
        field_path: Vec<String>,
        from_version: i64,
        to_version: i64,
        migration_source: String,
        pre_migration_snapshot: String,
    },
    BwTypeMigrationRenamingFieldIsOnlyAllowedAtTheSameStructLevel {
        type_name: String,
        from_prefix: Vec<String>,
        to_prefix: Vec<String>,
        from_version: i64,
        to_version: i64,
        migration_source: String,
        pre_migration_snapshot: String,
    },
    BwTypeMigrationRenamingFromAndToFieldsAreTheSame {
        type_name: String,
        from_path: Vec<String>,
        to_path: Vec<String>,
        from_version: i64,
        to_version: i64,
        migration_source: String,
        pre_migration_snapshot: String,
    },
    BwTypeMigrationRenamingFieldWithSuchNameAlreadyExists {
        type_name: String,
        from_path: Vec<String>,
        to_path: Vec<String>,
        from_version: i64,
        to_version: i64,
        migration_source: String,
        pre_migration_snapshot: String,
    },
    BwTypeMigrationRenamingFieldNotFound {
        type_name: String,
        from_path: Vec<String>,
        to_path: Vec<String>,
        from_version: i64,
        to_version: i64,
        migration_source: String,
        pre_migration_snapshot: String,
    },
    BwTypeMigrationRenamingFieldExpectedInnerStructFoundGroundType {
        type_name: String,
        from_path: Vec<String>,
        to_path: Vec<String>,
        from_version: i64,
        to_version: i64,
        migration_source: String,
        pre_migration_snapshot: String,
    },
    BwTypeFieldMutatedMoreThanOnceDuringMigration {
        type_name: String,
        from_path: Vec<String>,
        to_path: Vec<String>,
        from_version: i64,
        to_version: i64,
        migration_source: String,
        pre_migration_snapshot: String,
    },
    BwTypeLastFieldCannotBeOptional {
        type_name: String,
        path: Vec<String>,
        to_version: i64,
        migration_source: String,
    },
    HttpPathBadFormat {
        explanation: String,
        path: String,
    },
    HttpCantParseQueryArgument {
        full_path: String,
        expected_segment_example: &'static str,
        actual_segment: String,
    },
    HttpEmptyCorePath {
        full_path: String,
    },
    HttpCorePathMustStartWithSlash {
        full_path: String,
    },
    HttpMultipleConsecutiveSlashesNotAllowed {
        full_path: String,
    },
    HttpMultipleArgumentsOnlyAllowedInQuery {
        bad_argument_name: String,
        full_path: String,
    },
    HttpInvalidArgumentType {
        full_path: String,
        segment: String,
        the_type: String,
        allowed_types: Vec<&'static str>,
    },
    HttpInvalidCoreSegment {
        full_path: String,
        segment: String,
        explanation: &'static str,
    },
    HttpPathDuplicateArgumentName {
        full_path: String,
        duplicate_arg_name: String,
    },
    HttpPathReservedArgumentName {
        full_path: String,
        reserved_arg_name: String,
    },
    HttpPathInputBwTypeNotFound {
        application_name: String,
        endpoint_name: String,
        full_path: String,
        input_body_type: String,
    },
    HttpPathOutputBwTypeNotFound {
        application_name: String,
        endpoint_name: String,
        full_path: String,
        output_body_type: String,
    },
    HttpEndpointGetMethodCannotHaveInputBody {
        application_name: String,
        endpoint_name: String,
        full_path: String,
        input_body_type: String,
    },
    HttpEndpointBodyTypeIsJsonButOutputBwTypeIsUnspecified {
        application_name: String,
        endpoint_name: String,
        full_path: String,
    },
    HttpEndpointBodyTypeIsJsonAndPostPutMethodButInputBwTypeIsUnspecified {
        application_name: String,
        endpoint_name: String,
        full_path: String,
        http_method: String,
    },
    HttpEndpointDataTypeIsRawButInputBodyTypeIsSpecified {
        application_name: String,
        endpoint_name: String,
        full_path: String,
        http_method: String,
        input_body_type: String,
    },
    HttpEndpointDataTypeIsRawButOutputBodyTypeIsSpecified {
        application_name: String,
        endpoint_name: String,
        full_path: String,
        http_method: String,
        output_body_type: String,
    },
    HttpEndpointReceiveBodyAsStreamIsOnlySupportedForRawEndpointsWithRawInputBodyType {
        application_name: String,
        endpoint_name: String,
        full_path: String,
        http_method: String,
        endpoint_data_type: String,
        input_body_type: String,
        expected_endpoint_data_type: String,
        expected_input_body_type: String,
    },
    SingleDcRegionMustHaveOnlyOneDatacenter {
        region: String,
        expected_count: usize,
        found_datacenters: Vec<String>,
    },
    MultiDcRegionMustHaveAtLeastThreeDatacenters {
        region: String,
        expected_at_least: usize,
        found_datacenters: Vec<String>,
    },
    ConsulServerQuorumMustBeThreeOrFiveInRegion {
        region: String,
        found_consul_servers: Vec<String>,
    },
    ConsulServersQuorumTooManyServersInSingleDc {
        region: String,
        datacenter: String,
        total_consul_servers: usize,
        max_allowed_per_dc: usize,
        found_in_dc: usize,
        consul_servers_in_dc: Vec<String>,
    },
    NomadServersQuorumMustBeThreeOrFiveInRegion {
        region: String,
        found_nomad_servers: Vec<String>,
    },
    NomadServersQuorumTooManyServersInSingleDc {
        region: String,
        datacenter: String,
        total_nomad_servers: usize,
        max_allowed_per_dc: usize,
        found_in_dc: usize,
        nomad_servers_in_dc: Vec<String>,
    },
    VaultServersQuorumMustBeThreeOrFiveInRegion {
        region: String,
        found_vault_instances: Vec<String>,
    },
    VaultServersQuorumTooManyServersInSingleDc {
        region: String,
        datacenter: String,
        total_vault_servers: usize,
        max_allowed_per_dc: usize,
        found_in_dc: usize,
        vault_servers_in_dc: Vec<String>,
    },
    DoublePortUseAttemptDetected {
        server_hostname: String,
        port: u16,
        previous_use_comment: String,
        duplicate_use_comment: String,
    },
    DoublePortUseForAllServersAttemptDetected {
        port: u16,
        previous_use_comment: String,
        duplicate_use_comment: String,
    },
    ServerVolumeUsageContractBreachDetected {
        server_hostname: String,
        contract: String,
        read_locks: Vec<String>,
        write_locks: Vec<String>,
    },
    ServerCannotReserveMoreMemory {
        server_hostname: String,
        memory_reservation_log: Vec<(String, i64)>,
        total_sum: i64,
        server_memory: i64,
    },
    ServerCannotReserveMoreStatelessMemory {
        server_hostname: String,
        memory_reservation_log: Vec<(String, i64)>,
        total_sum: i64,
        server_memory: i64,
        servers_already_hosting_this_workload: Vec<String>,
    },
    ServerCannotPlaceStatelessWorkload {
        needed_bytes: Vec<(String, i64)>,
        servers_disallowed_to_run_unassigned_workloads: Vec<String>,
    },
    ServerCannotReserveMoreStatelessPlacedMemory {
        server_hostname: String,
        placement_labels: String,
        memory_reservation_log: Vec<(String, i64)>,
        total_sum: i64,
        server_memory: i64,
        all_placement_servers: Vec<String>,
    },
    SecretsFileCannotBeOpened {
        secrets_file_path: String,
        error: String,
    },
    SecretsFileCannotBeDeserialized {
        secrets_file_path: String,
        deserialization_error: String,
    },
    SecretsChecksumsFileCannotBeOpened {
        checksums_file_path: String,
        error: String,
    },
    SecretsChecksumsFileCannotBeDeserialized {
        checksums_file_path: String,
        deserialization_error: String,
    },
    SecretInSecretsFileDoesNotExistInChecksumFile {
        secrets_file_path: String,
        checksums_file_path: String,
        key: String,
    },
    AttemptedToLockServerTwiceWithSameLabel {
        lock_label: String,
        server_hostname: String,
    },
    ChecksumInChecksumsFileDoesNotExistInSecretsFile {
        secrets_file_path: String,
        checksums_file_path: String,
        key: String,
    },
    ChecksumMismatchForKey {
        secrets_file_path: String,
        checksums_file_path: String,
        key: String,
        expected_secret_checksum: String,
        actual_secret_checksum: String,
    },
    CannotWriteSecretsFile {
        secrets_file_path: String,
        error: String,
    },
    CannotWriteChecksumsFile {
        checksums_file_path: String,
        error: String,
    },
    MinIOMonitoringClusterDoesntExistInRegion {
        minio_cluster: String,
        minio_region: String,
        not_found_monitoring_cluster: String,
        available_monitoring_clusters: Vec<String>,
    },
    MinIOLoggingClusterDoesntExistInRegion {
        minio_cluster: String,
        minio_region: String,
        not_found_loki_cluster: String,
        available_loki_clusters: Vec<String>,
    },
    MinIOMustHaveAtLeastTwoInstances {
        cluster: String,
        count: usize,
        min_count: usize,
    },
    MinIOClusterInstanceIsOutsideSpecifiedRegion {
        cluster: String,
        cluster_region: String,
        server: String,
        server_region: String,
    },
    MinIODoubleUseOfExclusiveBucketDetected {
        minio_cluster: String,
        minio_bucket: String,
        previous_usage: String,
        clashing_usage: String,
    },
    MinIOUnexpectedZfsRecordsizeOnVolume {
        minio_cluster: String,
        minio_server: String,
        minio_volume: String,
        volume_source: String,
        expected_recordsize: String,
        found_recordsize: String,
    },
    MinIOMultipleFilesystemsDetectedInCluster {
        minio_cluster: String,
        filesystems: Vec<String>,
    },
    MinIOMultipleDiskMediumsDetectedInCluster {
        minio_cluster: String,
        disk_mediums: Vec<String>,
    },
    MultiplePlatformValidationErrorsFound {
        errors: Vec<PlatformValidationError>,
    },
    NomadTaskHasNoMemoryAssignedToIt {
        nomad_job: String,
        nomad_task_group: String,
        nomad_task_name: String,
        memory_bytes: i64,
    },
    RegionDoesntHaveDockerRegistryInstanceSpecified {
        region: String,
    },
    DockerRegistryAndMinioClusterAreInDifferentRegions {
        docker_registry_region: String,
        minio_cluster: String,
        minio_cluster_region: String,
    },
    NomadStatefulJobHasNoServerLocks {
        job_name: String,
        task_group_name: String,
    },
    NomadStatefulJobHasNonOneCount {
        job_name: String,
        task_group_name: String,
        count_expected: usize,
        count_actual: usize,
    },
    NomadStatelessJobHasServerLocks {
        job_name: String,
        task_group_name: String,
        lock_name: String,
    },
    NomadStatelessJobZeroInstanceCount {
        job_name: String,
        task_group_name: String,
        instance_count: usize,
    },
    NomadSystemStatelessJobNonOneCount {
        job_name: String,
        task_group_name: String,
        count_expected: usize,
        count_actual: usize,
    },
    NomadBoundStatefulJobCanOnlyHaveBoundMemory {
        job_name: String,
        task_group_name: String,
        task: String,
        memory_bytes: i64,
        comment: String,
        actual_kind: String,
    },
    NomadStatelessJobCanOnlyHaveStatelessMemory {
        job_name: String,
        task_group_name: String,
        task: String,
        memory_bytes: i64,
        comment: String,
        actual_kind: String,
    },
    NomadSystemStatelessJobCanOnlyHaveEveryServerMemory {
        job_name: String,
        task_group_name: String,
        task: String,
        memory_bytes: i64,
        comment: String,
        actual_kind: String,
    },
    ExternalLbRouteIsDuplicated {
        tld: String,
        subdomain: String,
        path: String,
    },
    InvalidSubdomainValue {
        subdomain: String,
    },
    NomadVolumeNameClashOnServer {
        server_hostname: String,
        duplicate_volume_name: String,
    },
    AppHttpTreeErrorDuplicatePagePath {
        application_name: String,
        previous_endpoint_name: String,
        previous_endpoint_path: String,
        duplicate_endpoint_name: String,
        duplicate_endpoint_path: String,
        page_method: String,
    },
    AppHttpTreeErrorArgPageMixedWithStaticPage {
        application_name: String,
        a_endpoint_name: String,
        a_endpoint_path: String,
        b_endpoint_name: String,
        b_endpoint_path: String,
    },
    AppHttpTreeErrorArgPageSegmentMultipleNames {
        application_name: String,
        arg_a_endpoint_name: String,
        arg_a_endpoint_path: String,
        arg_b_endpoint_name: String,
        arg_b_endpoint_path: String,
    },
    AppHttpTreeErrorArgPageTakenTwice {
        application_name: String,
        arg_a_endpoint_name: String,
        arg_a_endpoint_path: String,
        arg_b_endpoint_name: String,
        arg_b_endpoint_path: String,
        page_method: String,
    },
    AppIngressDuplicateEndpointInEndpointList {
        deployment: String,
        application_name: String,
        duplicate_endpoint: String,
        endpoints_list: String,
    },
    AppIngressEndpointNotFound {
        deployment: String,
        application_name: String,
        non_existing_endpoint: String,
        endpoints_list: String,
        available_endpoints: String,
    },
    AppIngressInvalidMountpoint {
        deployment: String,
        application_name: String,
        mountpoint: String,
        explanation: &'static str,
    },
    AppIngressClashError {
        deployment: String,
        application_name: String,
        mountpoint: String,
        error: String,
    },
    MonitoringInstancesMustAtLeastTwoToThree {
        cluster_name: String,
        minimum_count: i32,
        maximum_count: i32,
        current_count: usize,
    },
    AlertmanagerInstancesMustBeThreeOrFive {
        cluster_name: String,
        current_count: usize,
        valid_counts: Vec<usize>,
    },
    MonitoringInstanceIsOutsideSpecifiedRegion {
        monitoring_cluster: String,
        monitoring_cluster_region: String,
        server: String,
        server_region: String,
    },
    TempoClusterMinIOBucketIsOutsideSpecifiedRegion {
        tempo_cluster: String,
        tempo_cluster_region: String,
        minio_cluster: String,
        minio_cluster_region: String,
    },
    TempoMonitoringClusterDoesntExistInRegion {
        tempo_cluster: String,
        tempo_region: String,
        not_found_monitoring_cluster: String,
        available_monitoring_clusters: Vec<String>,
    },
    TempoLoggingClusterDoesntExistInRegion {
        tempo_cluster: String,
        tempo_region: String,
        not_found_loki_cluster: String,
        available_loki_clusters: Vec<String>,
    },
    LokiMonitoringClusterDoesntExistInRegion {
        loki_cluster: String,
        loki_region: String,
        not_found_monitoring_cluster: String,
        available_monitoring_clusters: Vec<String>,
    },
    LokiLoggingClusterDoesntExistInRegion {
        loki_cluster: String,
        loki_region: String,
        not_found_loki_cluster: String,
        available_loki_clusters: Vec<String>,
    },
    LokiClusterMinIOBucketIsOutsideSpecifiedRegion {
        loki_cluster: String,
        loki_cluster_region: String,
        minio_cluster: String,
        minio_cluster_region: String,
    },
    NoLoggingClusterInsideRegion {
        region_name: String,
    },
    NoRegionDefaultLoggingClusterSpecified {
        region_name: String,
        region_clusters: Vec<String>,
        region_default_clusters: Vec<String>,
    },
    MoreThanOneDefaultLoggingClusterFoundInRegion {
        region_name: String,
        region_default_clusters: Vec<String>,
    },
    NoMonitoringClusterInsideRegion {
        region_name: String,
    },
    NoRegionDefaultMonitoringClusterSpecified {
        region_name: String,
        region_clusters: Vec<String>,
        region_default_clusters: Vec<String>,
    },
    MoreThanOneDefaultMonitoringClusterFoundInRegion {
        region_name: String,
        region_default_clusters: Vec<String>,
    },
    NoTempoClusterInsideRegion {
        region_name: String,
    },
    NoRegionDefaultTempoClusterSpecified {
        region_name: String,
        region_clusters: Vec<String>,
        region_default_clusters: Vec<String>,
    },
    MoreThanOneDefaultTempoClusterFoundInRegion {
        region_name: String,
        region_default_clusters: Vec<String>,
    },
    AlertTriggerTestCantParseSeries {
        error: String,
        input_data: String,
        alert_name: String,
        test_expected_message: String,
    },
    CantReadPrometheusSeriesDatabase {
        filename: String,
        error: String,
    },
    CantParsePrometheusSeriesDatabase {
        filename: String,
        error: String,
    },
    AlertsTestsRequireMetricsDatabaseToBeInitialized,
    AlertTriggerTestCantParseSeriesExpression {
        input_data: String,
        error: String,
        alert_name: String,
        test_expected_message: String,
    },
    AlertTriggerTestSeriesDuplicateLabel {
        input_data: String,
        duplicate_label_name: String,
        alert_name: String,
        test_expected_message: String,
    },
    AlertTriggerTestMetricDoesntExistInDb {
        series_expression: String,
        missing_metric: String,
        alert_name: String,
        test_expected_message: String,
    },
    AlertTriggerTestMetricLabelDoesntExistInDb {
        series_expression: String,
        metric: String,
        missing_label: String,
        existing_labels: Vec<String>,
        alert_name: String,
        test_expected_message: String,
    },
    AlertMustHaveAtLeastOneTriggerTest {
        testless_alert: String,
    },
    AlertTriggerTestCantParseExpectedLabels {
        error: String,
        input_data: String,
        alert_name: String,
        test_expected_message: String,
    },
    AlertTriggerTestsFailed {
        output: String,
    },
    AlertTriggerTestSeriesIsNotFoundInExpression {
        alert_name: String,
        alert_expression: String,
        test_expected_message: String,
        series_not_found: String,
        series_expression: String,
        input_data: String,
    },
    ApplicationInvalidBuildEnvironmentKind {
        application_name: String,
        expected_compilation_environment_kind: String,
        found_compilation_environment_kind: String,
    },
    FrontendApplicationLoggingClusterDoesntExistInRegion {
        application_deployment: String,
        application_name: String,
        application_region: String,
        not_found_loki_cluster: String,
        available_loki_clusters: Vec<String>,
    },
    FrontendApplicationHasNoPages {
        application_name: String,
    },
    FrontendApplicationDeploymentHasMoreThanOneIngress {
        application_name: String,
        deployment_name: String,
        maximum_allowed: usize,
        actual: usize,
    },
    FrontendApplicationDeploymentHasNoIngress {
        application_name: String,
        deployment_name: String,
        ingress_count: usize,
    },
    FrontendApplicationUsedEndpointNotDeployed {
        application_name: String,
        deployment_name: String,
        missing_endpoint_name: String,
        missing_endpoint_backend_name: String,
        missing_endpoint_backend_signature: String,
    },
    FrontendApplicationUsedEndpointAmbigiousIngress {
        application_name: String,
        deployment_name: String,
        ambigous_endpoint_name: String,
        ambigous_endpoint_backend_name: String,
        ambigous_endpoint_backend_signature: String,
        matching_ingress_deployment_names: Vec<String>,
        matching_ingress_mountpoints: Vec<String>,
        tld: String,
        subdomain: String,
    },
    FrontendApplicationEndpointWiringInvalidLine {
        application_name: String,
        deployment_name: String,
        invalid_line: String,
        endpoint_wiring: String,
        explanation: String,
    },
    FrontendApplicationEndpointWiringNonExistingUsedEndpoint {
        application_name: String,
        deployment_name: String,
        non_existing_endpoint: String,
        valid_candidate_endpoints: Vec<String>,
        endpoint_wiring: String,
    },
    FrontendApplicationEndpointWiringNonExistingBackendDeployment {
        application_name: String,
        deployment_name: String,
        non_existing_deployment: String,
        endpoint_wiring: String,
    },
    FrontendApplicationEndpointWiringIncorrectTargetApplication {
        application_name: String,
        deployment_name: String,
        expected_backend_application: String,
        actual_backend_application: String,
        endpoint_wiring_line: String,
        endpoint_wiring: String,
    },
    FrontendApplicationEndpointWiringTargetDeploymentHasNoIngress {
        application_name: String,
        deployment_name: String,
        backend_application_deployment_without_ingress: String,
        endpoint_wiring_line: String,
        endpoint_wiring: String,
    },
    FrontendApplicationEndpointWiringCantFindCompatibleIngress {
        application_name: String,
        deployment_name: String,
        endpoint_wiring_line: String,
        endpoint_wiring: String,
        explanation: String,
    },
    FrontendApplicationEndpointWiringEndpointDefinedTwice {
        application_name: String,
        deployment_name: String,
        endpoint_defined_twice: String,
        endpoint_wiring: String,
    },
    FrontendApplicationEndpointDisallowedDataType {
        frontend_application_name: String,
        backend_application_name: String,
        backend_endpoint_name: String,
        backend_endpoint_data_type: String,
        backend_endpoint_allowed_types: Vec<String>,
        backend_endpoint_path: String,
    },
    FrontendApplicationPageWiringInvalidLine {
        application_name: String,
        deployment_name: String,
        invalid_line: String,
        page_wiring: String,
        explanation: String,
    },
    FrontendApplicationPageWiringUnknownPage {
        application_name: String,
        deployment_name: String,
        non_existing_page: String,
        valid_link_pages: Vec<String>,
        invalid_line: String,
        page_wiring: String,
    },
    FrontendApplicationPageWiringUnknownFrontendDeployment {
        application_name: String,
        deployment_name: String,
        non_existing_frontend_deployment: String,
        invalid_line: String,
        page_wiring: String,
    },
    FrontendApplicationPageWiringPointsToTheSameDeployment {
        application_name: String,
        deployment_name: String,
        same_frontend_deployment: String,
        invalid_line: String,
        page_wiring: String,
    },
    FrontendApplicationPageWiringPointsToUnexpectedFrontendApp {
        application_name: String,
        deployment_name: String,
        expected_frontend_app: String,
        actual_frontend_app: String,
        invalid_line: String,
        page_wiring: String,
    },
    FrontendApplicationPageWiringTargetDeploymentHasNoIngress {
        application_name: String,
        deployment_name: String,
        frontend_application_deployment_without_ingress: String,
        invalid_line: String,
        page_wiring: String,
    },
    FrontendApplicationPageWiringLinkDefinedMultipleTimes {
        application_name: String,
        deployment_name: String,
        page_defined_multiple_times: String,
        invalid_line: String,
        page_wiring: String,
    },
    FrontendApplicationPageWiringExternalPageUndefined {
        application_name: String,
        deployment_name: String,
        undefined_page: String,
        page_wiring: String,
    },
    FrontendApplicationLinkWiringBadEndpointDataType {
        application_name: String,
        bad_endpoint: String,
        bad_endpoint_data_type: String,
        allowed_endpoint_types: Vec<String>,
    },
    FrontendApplicationLinkWiringUnknownEndpoint {
        application_name: String,
        deployment_name: String,
        non_existing_endpoint: String,
        valid_endpoints: Vec<String>,
        invalid_line: String,
        link_wiring: String,
    },
    FrontendApplicationLinkWiringUnknownBackendDeployment {
        application_name: String,
        deployment_name: String,
        non_existing_backend_deployment: String,
        invalid_line: String,
        link_wiring: String,
    },
    FrontendApplicationLinkWiringPointsToUnexpectedBackendApp {
        application_name: String,
        deployment_name: String,
        expected_backend_app: String,
        actual_backend_app: String,
        invalid_line: String,
        link_wiring: String,
    },
    FrontendApplicationLinkWiringBackendDeploymentHasNoIngress {
        application_name: String,
        deployment_name: String,
        backend_application_deployment_without_ingress: String,
        invalid_line: String,
        link_wiring: String,
    },
    FrontendApplicationLinkWiringLinkDefinedMultipleTimes {
        application_name: String,
        deployment_name: String,
        link_defined_multiple_times: String,
        invalid_line: String,
        link_wiring: String,
    },
    FrontendApplicationLinkWiringInvalidLine {
        application_name: String,
        deployment_name: String,
        invalid_line: String,
        link_wiring: String,
        explanation: String,
    },
    FrontendApplicationLinkWiringExternalLinkUndefined {
        application_name: String,
        deployment_name: String,
        undefined_link: String,
        link_wiring: String,
    },
    DnsRegionNameAndIngressSubdomainFqdnClash {
        fqdn: String,
        clash_source_table: &'static str,
    },
    DnsMasterMustHaveInternetNetworkInterface {
        server: String,
        found_interfaces: Vec<String>,
    },
    DnsSlaveMustHaveInternetNetworkInterface {
        server: String,
        found_interfaces: Vec<String>,
    },
    DnsHasMoreThanOneMaster {
        first_master_server: String,
        second_master_server: String,
    },
    DnsHasMoreThanTwoSlaves {
        slave_servers: Vec<String>,
    },
    DnsNoMasterServerSpecifiedInRegion {
        explanation: String,
    },
    DnsNoSlaveServersSpecifiedInRegion {
        explanation: String,
    },
    DnsMoreThanOneMasterRegion {
        first_master_region: String,
        first_master_server: String,
        second_master_region: String,
        second_master_server: String,
    },
    DnsMoreThanTwoSlaveRegions {
        slave_regions: Vec<String>,
        slave_servers: Vec<String>,
    },
    DnsNoMasterRegionSpecified {
        explanation: String,
    },
    DnsNoSlaveRegionSpecified {
        explanation: String,
    },
    // 4 minimum is because MinIO per datacenter
    RegionWithDeploymentsHasLessThanFourServers {
        region: String,
        servers: Vec<String>,
        minimum: usize,
    },
    RegionWithIngressesHasLessThanTwoIngressServers {
        region: String,
        ingress_servers: Vec<String>,
        minimum: usize,
    },
    RegionWithIngressesHasInconsistentIpV6IngressCount {
        region: String,
        ipv4_ingress_servers: Vec<String>,
        ipv6_ingress_servers: Vec<String>,
        expected_ipv6_ingress_count: usize,
        is_ipv6_support_enabled: bool,
        is_ipv6_support_forced: bool,
    },
    ServerMarkedAsIngressHasNoPublicIpInterface {
        datacenter: String,
        server: String,
        missing_network_interface: String,
        existing_network_interfaces: Vec<String>,
    },
    NatsMonitoringClusterDoesntExistInRegion {
        nats_cluster: String,
        nats_region: String,
        not_found_monitoring_cluster: String,
        available_monitoring_clusters: Vec<String>,
    },
    NatsLoggingClusterDoesntExistInRegion {
        nats_cluster: String,
        nats_region: String,
        not_found_loki_cluster: String,
        available_loki_clusters: Vec<String>,
    },
    NatsClusterInstancesCountMustBeThreeOrFive {
        nats_cluster: String,
        nats_region: String,
        nats_instance_count: usize,
    },
    NatsClusterInstanceIsOutsideSpecifiedRegion {
        nats_cluster: String,
        nats_cluster_region: String,
        server: String,
        server_region: String,
    },
    GrafanaMonitoringClusterDoesntExistInRegion {
        grafana_deployment: String,
        grafana_region: String,
        not_found_monitoring_cluster: String,
        available_monitoring_clusters: Vec<String>,
    },
    GrafanaLoggingClusterDoesntExistInRegion {
        grafana_deployment: String,
        grafana_region: String,
        not_found_loki_cluster: String,
        available_loki_clusters: Vec<String>,
    },
    GrafanaDatabaseIsOutsideSpecifiedRegion {
        grafana_deployment: String,
        grafana_region: String,
        pg_deployment: String,
        pg_deployment_region: String,
    },
    VpnGatewayServerPairMustHaveAtLeastOneInternetInterface {
        server_a: String,
        server_a_has_internet_interface: bool,
        server_b: String,
        server_b_has_internet_interface: bool,
    },
    VpnGatewayServerMustHaveVpnInterface {
        server: String,
        server_dc: String,
        network_interfaces: Vec<String>,
    },
    VpnGatewayServerVpnInterfaceNameMustBeWg0 {
        server: String,
        network: String,
        expected_interface_name: String,
        actual_interface_name: String,
    },
    VpnInterfaceExistsButServerIsNotMarkedVpnGateway {
        server_name: String,
        vpn_interface_ip: String,
    },
    VpnAddressReservedForAdmin {
        server_name: String,
        vpn_interface_ip: String,
        forbidden_vpn_ip: String,
    },
    DcMustHaveExactlyTwoVpnGateways {
        dc: String,
        vpn_gateway_servers: Vec<String>,
        expected_count: usize,
        actual_count: usize,
    },
    DcSubnetHasTooFewHosts {
        dc: String,
        subnet: String,
        servers_count: usize,
        minimum_count: usize,
    },
    DcrouterInterfaceExistsButServerIsNotMarkedAsRouter {
        server_name: String,
        router_interface_ip: String,
    },
    DcrouterServerMustHaveDcrouterInterface {
        server: String,
        server_dc: String,
        network_interfaces: Vec<String>,
    },
    DcRoutingSubnetMustHaveExactlyTwoRouters {
        dc: String,
        subnet: String,
        router_servers: Vec<String>,
        expected_router_servers: usize,
    },
    DcRoutingSubnetCannotMixDeclaredVpnGatewaysAndDeclaredRouters {
        dc: String,
        subnet: String,
        declared_router_server_found: Vec<String>,
        declared_vpn_gateways_found: Vec<String>,
    },
    InvalidSubnetRouterFloatingIp {
        value: String,
        parsing_error: String,
        valid_example: String,
    },
    SubnetRouterFloatingIpDoesntBelongToLanNetwork {
        value: String,
        expected_to_be_in_network: String,
    },
    SubnetRouterFloatingIpInvalidPrefixLength {
        value: String,
        expected_prefix_length: String,
    },
    SubnetRouterFloatingIpCannotBeNetworkAddress {
        value: String,
        network_address: String,
    },
    SubnetRouterFloatingIpCannotBeBroadcastAddress {
        value: String,
        broadcast_address: String,
    },
    SubnetRouterFloatingIpCannotBeFirstAddressInNetwork {
        value: String,
    },
    SubnetRouterFloatingIpForSubnetNotFound {
        subnet: String,
    },
    SubnetRouterFloatingIpDefinedButNeverUsed {
        subnet_router_floating_ip: String,
    },
    SubnetRouterTwoFloatingIpsFoundForNetwork {
        network: String,
        floating_ip_a: String,
        floating_ip_b: String,
    },
    SubnetRouterFloatingIpClashWithServerIp {
        server: String,
        server_ip: String,
        subnet_router_floating_ip: String,
    },
    MoreThanOneDatacenterButNoVpnNetworkToConnectThem {
        datacenter_count: usize,
        missing_network: String,
    },
    IntraDcRoutingNeededButNoDcrouterNetworkExists {
        dc: String,
        subnet_count: usize,
        missing_network: String,
    },
    DatacenterImplementationInvalidSettings {
        dc: String,
        dc_implementation: String,
        current_settings: String,
        parsing_error: String,
        example_settings: String,
    },
    DatacenterImplementationDoesntAllowMoreThanOneSubnet {
        dc: String,
        subnet_count: usize,
        max_subnets: usize,
    },
    AwsDatacenterUnknownAvailabilityZone {
        dc: String,
        dc_implementation: String,
        unknown_availability_zone: String,
        current_settings: String,
    },
    AwsSameAvailabilityZoneUsedForMultipleDatacenters {
        duplicate_az: String,
        previous_dc: String,
        current_dc: String,
    },
    AwsMoreThanAwsOneRegionInsideEdenPlatformRegion {
        eden_platform_region: String,
        found_aws_regions: Vec<String>,
    },
    AwsRegionIsUsedInMoreThanOneEdenPlatformRegion {
        overused_aws_region: String,
        epl_regions_using_aws_region: Vec<String>,
    },
    AwsLanNetworkInterfaceNameMustBeEth0 {
        aws_dc: String,
        aws_server: String,
        aws_lan_network_interface: String,
        aws_lan_network_interface_only_allowed_name: String,
    },
    AwsDcrouterNetworkInterfaceNameMustBeEth1 {
        aws_dc: String,
        aws_server: String,
        aws_network_interface: String,
        aws_network_interface_only_allowed_name: String,
    },
    AwsSshInterfaceForPublicServerMustBePublic {
        aws_dc: String,
        aws_server: String,
        aws_server_ssh_interface: String,
        aws_server_expected_ssh_interface: String,
    },
    AwsInternetInterfaceMustHave32Prefix {
        aws_dc: String,
        aws_server: String,
        aws_server_interface: String,
        aws_server_mask: i64,
        aws_server_only_allowed_mask: i64,
    },
    AwsPublicIpv6AddressMustHave128AsPrefix {
        aws_dc: String,
        aws_server: String,
        aws_server_ipv6_prefix: i64,
        aws_server_only_allowed_prefix: i64,
    },
    AwsArtefactsBucketIsUndefined {
        table_name: String,
        table_column: String,
        current_value: String,
    },
    AwsArtefactsBucketIsTooLong {
        table_name: String,
        table_column: String,
        current_value: String,
        current_length: usize,
        max_length: usize,
    },
    AwsArtefactsBucketHasNonKebabCaseName {
        table_name: String,
        table_column: String,
        current_value: String,
    },
    AwsNotUsedButArtefactsBucketIsDefined {
        table_name: String,
        table_column: String,
        current_value: String,
    },
    AwsDatacenterDefaultServerKindMustStartWithAws {
        aws_datacenter: String,
        invalid_server_kind: String,
        expected_server_kind_prefix: String,
    },
    AwsEveryServerKindInAwsMustStartWithAws {
        aws_server: String,
        server_kind: String,
        expected_server_kind_prefix: String,
    },
    AwsEveryDiskKindInAwsMustStartWithAws {
        aws_server: String,
        disk_id: String,
        disk_kind: String,
        expected_disk_kind_prefix: String,
    },
    AwsAddingCustomInstanceTypesIsNotAllowed {
        alien_aws_server_kind: String,
    },
    AwsAddingCustomDiskKindsIsNotAllowed {
        alien_aws_disk_kind: String,
    },
    AwsDiskSizeMustBeMultipleOfGigabyte {
        aws_server: String,
        disk_id: String,
        disk_size: i64,
        remainder_of_current_gigabyte: i64,
        bytes_until_next_gigabyte: i64,
    },
    AwsDiskKindIsNotAllowedToBeRoot {
        aws_server: String,
        disk_id: String,
        disk_kind: String,
        forbidden_root_disk_kinds: Vec<String>,
    },
    AwsRootDiskOnHypervisorMustBeNamedThis {
        aws_server: String,
        hypervisor: String,
        root_disk_id: String,
        root_disk_only_expected_id: String,
    },
    AwsNonRootDiskMustFollowRecommendedConvention {
        aws_server: String,
        non_root_disk_id: String,
        must_match_regex: String,
    },
    AwsInvalidDiskExtraConfig {
        aws_server: String,
        aws_disk_id: String,
        aws_disk_kind: String,
        config_provided: String,
        example_valid_config: String,
        error: String,
    },
    AwsCannotUseDiskKindOnHypervisorInstance {
        aws_server: String,
        aws_disk_id: String,
        aws_disk_kind: String,
        server_hypervisor: String,
        only_allowed_hypervisors_for_disk_kind: Vec<String>,
    },
    GcloudDatacenterUnknownAvailabilityZone {
        dc: String,
        dc_implementation: String,
        unknown_availability_zone: String,
        current_settings: String,
    },
    GcloudSameAvailabilityZoneUsedForMultipleDatacenters {
        duplicate_az: String,
        previous_dc: String,
        current_dc: String,
    },
    GcloudMoreThanGcloudOneRegionInsideEdenPlatformRegion {
        eden_platform_region: String,
        found_gcloud_regions: Vec<String>,
    },
    GcloudRegionIsUsedInMoreThanOneEdenPlatformRegion {
        overused_gcloud_region: String,
        epl_regions_using_gcloud_region: Vec<String>,
    },
    GcloudDcrouterNetworkInterfaceNameMustBeEth1 {
        gcloud_dc: String,
        gcloud_server: String,
        gcloud_dcrouter_network_interface: String,
        gcloud_dcrouter_network_interface_only_allowed_name: String,
    },
    GcloudLanNetworkInterfaceNameMustBeEth0 {
        gcloud_dc: String,
        gcloud_server: String,
        gcloud_public_network_interface: String,
        gcloud_public_network_interface_only_allowed_name: String,
    },
    GcloudSshInterfaceForPublicServerMustBePublic {
        gcloud_dc: String,
        gcloud_server: String,
        gcloud_server_ssh_interface: String,
        gcloud_server_expected_ssh_interface: String,
    },
    GcloudInternetInterfaceMustHave32Prefix {
        gcloud_dc: String,
        gcloud_server: String,
        gcloud_server_interface: String,
        gcloud_server_mask: i64,
        gcloud_server_only_allowed_mask: i64,
    },
    GcloudProjectIdIsUndefined {
        table_name: String,
        table_column: String,
        current_value: String,
    },
    GcloudArtefactsBucketIsUndefined {
        table_name: String,
        table_column: String,
        current_value: String,
    },
    GcloudArtefactsBucketIsTooLong {
        table_name: String,
        table_column: String,
        current_value: String,
        current_length: usize,
        max_length: usize,
    },
    GcloudArtefactsBucketHasNonKebabCaseName {
        table_name: String,
        table_column: String,
        current_value: String,
    },
    GcloudNotUsedButProjectIdIsDefined {
        table_name: String,
        table_column: String,
        current_value: String,
    },
    GcloudNotUsedButArtefactsBucketIsDefined {
        table_name: String,
        table_column: String,
        current_value: String,
    },
    GcloudDatacenterDefaultServerKindMustStartWithGcloud {
        gcloud_datacenter: String,
        invalid_server_kind: String,
        expected_server_kind_prefix: String,
    },
    GcloudEverServerKindInGoogleCloudMustStartWithGcloud {
        gcloud_server: String,
        server_kind: String,
        expected_server_kind_prefix: String,
    },
    GcloudAddingCustomInstanceTypesIsNotAllowed {
        alien_gcloud_server_kind: String,
    },
    GcloudAddingCustomDiskKindsIsNotAllowed {
        alien_gcloud_disk_kind: String,
    },
    GcloudEveryDiskKindInGcloudMustStartWithGcloud {
        gcloud_server: String,
        disk_id: String,
        disk_kind: String,
        expected_disk_kind_prefix: String,
    },
    GcloudRootDiskMustBeNamedSda {
        gcloud_server: String,
        root_disk_id: String,
        root_disk_only_expected_id: String,
    },
    GcloudNonRootDiskMustFollowThisConvention {
        gcloud_server: String,
        non_root_disk_id: String,
        must_match_regex: String,
    },
    GcloudDiskSizeMustBeMultipleOfGigabyte {
        gcloud_server: String,
        disk_id: String,
        disk_size: i64,
        remainder_of_current_gigabyte: i64,
        bytes_until_next_gigabyte: i64,
    },
    GcloudTotalDiskSizeOnServerExceedsLimit {
        gcloud_server: String,
        total_disk_sizes_sum: i64,
        total_disk_size_limit: i64,
        explanation: String,
    },
    GcloudInvalidDiskExtraConfig {
        gcloud_server: String,
        gcloud_disk_id: String,
        gcloud_disk_kind: String,
        config_provided: String,
        example_valid_config: String,
        error: String,
    },
    BmSimpleGatewayIpIsOutsideDatacenterNetwork {
        bm_simple_datacenter: String,
        gateway_ip: String,
        dc_network: String,
    },
    BmSimpleOnlySubnetDoesntContainGatewayIp {
        bm_simple_datacenter: String,
        gateway_ip: String,
        only_dc_subnet: String,
    },
    TestVmsDatacentersCannotBeMixedWithProductionDatacenters {
        test_vm_datacenters: Vec<String>,
        production_datacenters: Vec<String>,
    },
    ForThisDatacenterImplementationAllInternetInterfaceNamesMustBeVoid {
        dc: String,
        dc_implementation: String,
        server: String,
        network: String,
        network_interface_name: String,
        network_interface_only_allowed_name: String,
    },
    EnvironmentMustHaveExactlyOneGlobalSettingsRow {
        table_name: String,
        expected_row_count: usize,
        actual_row_count: usize,
    },
    EnvironmentProjectNameCannotBeEmpty {
        table_name: String,
        column_name: String,
        value: String,
    },
    EnvironmentProjectNameMustBeNotTooLong {
        table_name: String,
        column_name: String,
        value: String,
        length: usize,
        max_length: usize,
    },
    EnvironmentProjectNameMustBeKebabCase {
        table_name: String,
        column_name: String,
        value: String,
    },
    ServerKindSpecifiedOnServerDoesntExist {
        server_hostname: String,
        non_existing_server_kind: String,
    },
    NodeKindCannotBeUsedInEdenPlatform {
        server_hostname: String,
        uneligible_server_kind: String,
        reason: String,
    },
    Arm64ServerKindsAreNotSupportedYet {
        server_hostname: String,
        unsupported_server_kind: String,
        unsupported_server_cpu_architecture: String,
    },
    UnsupportedEdenPlatformServerArchitecture {
        server_hostname: String,
        unsupported_server_kind: String,
        unsupported_server_cpu_architecture: String,
        supported_architectures: Vec<String>,
    },
    DockerImageChecksumDoesntStartWithSha256 {
        bad_image_checksum: String,
        repository: String,
        image_set: String,
        expected_prefix: String,
    },
    DockerImageChecksumBadLength {
        bad_image_checksum: String,
        repository: String,
        image_set: String,
        actual_length: usize,
        expected_length: usize,
    },
    DockerImageChecksumBadSymbols {
        bad_image_checksum: String,
        repository: String,
        image_set: String,
        only_allowed_checksum_characters: String,
    },
    DockerImagePinContainsMultipleImagesForSameArchitecture {
        image_pin_name: String,
        architecture: String,
        previous_docker_image: String,
        duplicate_docker_image: String,
    },
    DockerImageDoesNotBelongToTheExpectedSet {
        image_pin_name: String,
        image_architecture: String,
        image_checksum: String,
        image_repository: String,
        expected_docker_image_set: String,
        found_docker_image_set: String,
    },
    DockerImageNotFoundForArchitectureForPin {
        image_pin_name: String,
        architecture_image_not_found: String,
        found_architecture_images: Vec<String>,
    },
    NonAmd64BuildsNotSupportedYetForApplications {
        application_deployment: String,
        workload_architecture: String,
        only_allowed_workload_architecture: String,
    },
    InvalidServerLabelInQuery {
        invalid_label_key: String,
        label_value: String,
        placement_query: String,
    },
    LabelQueryParseError {
        placement_query: String,
        parsing_error: String,
    },
    FailedToFindPlacements {
        context: String,
        need_at_least: usize,
        found_servers_count: usize,
        placement_query: String,
        found_servers: Vec<String>,
    },
    ServerRootDiskCanOnlyBeFormattedAsZfs {
        server: String,
        root_disk_id: String,
        wanted_format: String,
        only_allowed_format: String,
    },
    ServerXfsVolumeIsNotOnXfsFormattedDisk {
        server: String,
        xfs_volume_name: String,
        xfs_disk_id: String,
        is_xfs_disk: bool,
    },
    ServerZpoolNameIsReserved {
        server: String,
        zpool_name: String,
        reserved_zpool_name: String,
    },
    ServerZpoolHasNoVdevs {
        server: String,
        zpool_name: String,
        vdev_count: usize,
    },
    ServerZpoolHasMoreThanOneVdevType {
        server: String,
        zpool_name: String,
        found_vdev_types: Vec<String>,
    },
    ServerZpoolVdevsIdSequenceDoesntStartWith1 {
        server: String,
        zpool_name: String,
        minimum_vdev_id: i64,
        only_allowed_minimum_vdev_id: i64,
    },
    ServerZpoolVdevsIdsAreNotSequential {
        server: String,
        zpool_name: String,
        current_vdev_ids: Vec<i64>,
        vdev_id_a: i64,
        vdev_id_b: i64,
        vdev_id_b_expected: i64,
    },
    ServerZpoolVdevsHaveUnequalAmountOfDisks {
        server: String,
        zpool_name: String,
        disk_counts_per_vdev_found: Vec<usize>,
    },
    ServerZpoolVdevHasNoDisks {
        server: String,
        zpool_name: String,
        vdev_index: i64,
        disks_found: usize,
    },
    ServerRedundantZpoolVdevHasOnlyOneDisk {
        server: String,
        zpool_name: String,
        vdev_index: i64,
        disks_found: usize,
        is_zpool_marked_redundant: bool,
    },
    ServerZpoolMirrorVdevHasMoreThanAllowedDisks {
        server: String,
        zpool_name: String,
        vdev_index: i64,
        disks_found: usize,
        maximum_allowed_disks: usize,
    },
    ServerZpoolRaidzVdevHasTooFewDisks {
        server: String,
        zpool_name: String,
        vdev_index: i64,
        raid_type: String,
        minimum_disks_required: usize,
        disks_found: usize,
    },
    ServerZpoolRaidzVdevHasTooManyDisks {
        server: String,
        zpool_name: String,
        vdev_index: i64,
        raid_type: String,
        maximum_disks_allowed: usize,
        disks_found: usize,
    },
    DoubleUsageOfServerDiskDetected {
        server: String,
        disk_id: String,
        previous_usage: String,
        another_usage: String,
    },
    ServerZpoolDifferentDiskSizesDetected {
        server: String,
        zpool_name: String,
        different_disk_sizes: Vec<i64>,
        different_disk_kinds_involved: Vec<String>,
    },
    ServerZpoolLogDifferentDiskSizesDetected {
        server: String,
        zpool_name: String,
        different_disk_sizes: Vec<i64>,
        different_disk_kinds_involved: Vec<String>,
    },
    ServerZpoolDifferentDiskMediumsDetected {
        server: String,
        zpool_name: String,
        different_disk_mediums: Vec<String>,
        different_disk_kinds_involved: Vec<String>,
    },
    ServerZpoolLogDifferentDiskMediumsDetected {
        server: String,
        zpool_name: String,
        different_disk_mediums: Vec<String>,
        different_disk_kinds_involved: Vec<String>,
    },
    ServerZpoolHasMoreThanOneVdevButHasElasticDisk {
        server: String,
        zpool_name: String,
        explanation: String,
        different_disk_kinds_involved: Vec<String>,
    },
    ServerZpoolCacheDeviceIsSlowerThanVdevDisks {
        server: String,
        zpool_name: String,
        cache_disk_id: String,
        fastest_vdev_medium: String,
        cache_disk_medium: String,
    },
    ServerZpoolCannotHaveMoreThanTwoLogDisks {
        server: String,
        zpool_name: String,
        log_devices_maximum: usize,
        log_devices_found: usize,
    },
    ServerNvmeNamedDiskIsNotNvmeMediumByDiskKind {
        server: String,
        disk_id: String,
        disk_kind: String,
        disk_kind_medium: String,
    },
    ServerDiskWithDiskKindIsNotSupportedForProvisioning {
        server: String,
        disk_id: String,
        disk_kind: String,
        non_eligible_reason: String,
    },
    DiskKindDiskIsElasticButHasSpecifiedCapacity {
        disk_kind: String,
        specified_capacity_bytes: i64,
        is_elastic: bool,
    },
    DiskKindDiskIsElasticButDoesntSpecifyMaxCapacity {
        disk_kind: String,
        max_capacity_bytes: i64,
        is_elastic: bool,
    },
    DiskKindDiskIsNotElasticButHasUnspecifiedCapacity {
        disk_kind: String,
        specified_capacity_bytes: i64,
        is_elastic: bool,
    },
    DiskKindDiskIsNotElasticButHasMaxCapacitySpecified {
        disk_kind: String,
        specified_max_capacity_bytes: i64,
        is_elastic: bool,
    },
    DiskKindDiskIsNotElasticButHasMinCapacitySpecified {
        disk_kind: String,
        specified_min_capacity_bytes: i64,
        is_elastic: bool,
    },
    DiskKindMinCapacityBiggerThanMaxCapacity {
        disk_kind: String,
        specified_min_capacity_bytes: i64,
        specified_max_capacity_bytes: i64,
        is_elastic: bool,
    },
    DiskKindDiskCapacityMustBeAtLeast1GB {
        disk_kind: String,
        specified_capacity_bytes: i64,
        minimum_capacity_bytes: i64,
        is_elastic: bool,
    },
    ServerDiskKindIsElasticButDiskSizeIsNotSpecified {
        server: String,
        disk_id: String,
        disk_kind: String,
        is_elastic: bool,
        specified_capacity_bytes: i64,
    },
    ServerDiskKindIsNotElasticButDiskSizeIsSpecified {
        server: String,
        disk_id: String,
        disk_kind: String,
        is_elastic: bool,
        specified_capacity_bytes: i64,
    },
    ServerDiskMinimumCapacityIs1GB {
        server: String,
        disk_id: String,
        disk_kind: String,
        is_elastic: bool,
        specified_capacity_bytes: i64,
    },
    ServerDiskRootDiskMustBeAtLeast5GB {
        server: String,
        disk_id: String,
        disk_kind: String,
        is_elastic: bool,
        is_root_disk: bool,
        minimum_root_disk_capacity_bytes: i64,
        specified_capacity_bytes: i64,
    },
    ServerDiskExceedsMaximumCapacityAllowedByDiskKind {
        server: String,
        disk_id: String,
        disk_kind: String,
        is_elastic: bool,
        specified_capacity_bytes: i64,
        maximum_disk_capacity_bytes: i64,
    },
    ServerDiskHasLowerThanMinimumCapacityAllowedByDiskKind {
        server: String,
        disk_id: String,
        disk_kind: String,
        is_elastic: bool,
        specified_capacity_bytes: i64,
        minimum_disk_capacity_bytes: i64,
    },
    ServerDiskHasExtraConfigNotAllowedForDiskKind {
        server: String,
        disk_id: String,
        disk_kind: String,
        extra_config: String,
        is_extra_config_allowed: bool,
    },
    ServerDiskIdUnexpectedFormatInDatacenter {
        server: String,
        disk_id: String,
        actual_disk_id_kind: String,
        datacenter: String,
        datacenter_implementation: String,
        datacenter_disk_ids_policy: String,
    },
    DetectedDuplicateDiskSerials {
        server_a: String,
        server_a_disk_id: String,
        server_b: String,
        server_b_disk_id: String,
    },
    CoprocessorDcMustHaveTwoGateways {
        region: String,
        region_availability_mode: String,
        region_has_coprocessor_dc: bool,
        region_dc: String,
        region_expected_coprocessor_gateways: usize,
        region_found_coprocessor_gateways: usize,
        region_found_coprocessor_gateways_servers: Vec<String>,
    },
    CoprocessorCannotHaveMoreThanOneGatewayInDatacenter {
        region: String,
        region_availability_mode: String,
        region_has_coprocessor_dc: bool,
        region_dc: String,
        region_expected_maximum_coprocessor_gateways_per_dc: usize,
        region_found_coprocessor_gateways: usize,
        region_found_coprocessor_gateways_servers: Vec<String>,
    },
    CoprocessorDcIsNotEnabledInRegionButCoprocessorServersExist {
        region: String,
        region_availability_mode: String,
        region_has_coprocessor_dc: bool,
        region_dc: String,
        region_expected_coprocessor_gateways: usize,
        region_found_coprocessor_gateways: usize,
        region_found_coprocessor_gateways_servers: Vec<String>,
    },
    CoprocessorRegionMustHaveTwoCoprocessorGateways {
        region: String,
        region_availability_mode: String,
        region_has_coprocessor_dc: bool,
        region_expected_coprocessor_gateways: usize,
        region_found_coprocessor_gateways: usize,
        region_found_coprocessor_gateways_servers: Vec<String>,
    },
    CoprocessorServerMustBeVPNGateway {
        region: String,
        datacenter: String,
        server: String,
        is_vpn_gateway: bool,
        is_coprocessor_gateway: bool,
    },
    CoprocessorDatacenterMustNotHaveCoprocessorGateways {
        region: String,
        datacenter: String,
        dc_implementation: String,
        dc_expected_coprocessor_gateways: usize,
        dc_found_coprocessor_gateways: usize,
        dc_found_coprocessor_gateways_servers: Vec<String>,
    },
    CoprocessorRegionDoesntHaveCoprocessorDc {
        region: String,
        coprocessor_dcs_found: usize,
        coprocessor_dcs_expected: usize,
        coprocessor_dcs: Vec<String>,
    },
    CoprocessorRegionHasMoreThanOneCoprocessorDc {
        region: String,
        coprocessor_dcs_found: usize,
        coprocessor_dcs_expected: usize,
        coprocessor_dcs: Vec<String>,
    },
    RegionNotMarkedAsCoprocessorHasCoprocessorDatacenters {
        region: String,
        region_has_coprocessor_dc: bool,
        coprocessor_dcs_found: usize,
        coprocessor_dcs_expected: usize,
        coprocessor_dcs: Vec<String>,
    },
    CoprocessorDatacenterServerHasForbiddenRole {
        region: String,
        datacenter: String,
        server_hostname: String,
        forbidden_role: String,
    },
    CoprocessorServerVpnInterfaceNamesMustBeWg0AndWg1 {
        region: String,
        datacenter: String,
        server_hostname: String,
        vpn_interface_name: String,
        only_allowed_names: Vec<String>,
    },
    CoprocessorServerMustHaveTwoVpnInterfaces {
        region: String,
        datacenter: String,
        server_hostname: String,
        vpn_interfaces_expected: usize,
        vpn_interfaces_found: usize,
        vpn_interfaces_found_names: Vec<String>,
    },
    ChKeeperDeploymentMonitoringClusterDoesntExistInRegion {
        ch_keeper_deployment: String,
        ch_keeper_region: String,
        not_found_monitoring_cluster: String,
        available_monitoring_clusters: Vec<String>,
    },
    ChKeeperDeploymentLoggingClusterDoesntExistInRegion {
        ch_keeper_deployment: String,
        ch_keeper_region: String,
        not_found_loki_cluster: String,
        available_loki_clusters: Vec<String>,
    },
    ChKeeperDeploymentInstanceIsOutsideSpecifiedRegion {
        ch_keeper_deployment: String,
        ch_keeper_region: String,
        server: String,
        server_region: String,
    },
    ChKeeperClusterInstancesCountMustBeThreeOrFive {
        ch_keeper_deployment: String,
        ch_keeper_region: String,
        ch_keeper_instance_count: usize,
    },
    ChDeploymentMonitoringClusterDoesntExistInRegion {
        ch_deployment: String,
        ch_region: String,
        not_found_monitoring_cluster: String,
        available_monitoring_clusters: Vec<String>,
    },
    ChDeploymentLoggingClusterDoesntExistInRegion {
        ch_deployment: String,
        ch_region: String,
        not_found_loki_cluster: String,
        available_loki_clusters: Vec<String>,
    },
    ChDeploymentInstancesCountMustBeAtLeastTwoButNoMoreThan10 {
        ch_deployment: String,
        ch_region: String,
        ch_instance_count: usize,
        min_instance_count: usize,
        max_instance_count: usize,
    },
    ChDeploymentInstanceIsOutsideSpecifiedRegion {
        ch_deployment: String,
        ch_region: String,
        server: String,
        server_region: String,
    },
    BlackboxDeploymentMonitoringClusterDoesntExistInRegion {
        bb_deployment: String,
        bb_region: String,
        not_found_monitoring_cluster: String,
        available_monitoring_clusters: Vec<String>,
    },
    BlackboxDeploymentLoggingClusterDoesntExistInRegion {
        bb_deployment: String,
        bb_region: String,
        not_found_loki_cluster: String,
        available_loki_clusters: Vec<String>,
    },
    BlackboxDeploymentPortsAreNotSequential {
        bb_deployment: String,
        bb_region: String,
        deployment_ports: Vec<i64>,
        port_a: i64,
        non_sequential_port_b: i64,
    },
    BlackboxDeploymentHasNoGroups {
        bb_deployment: String,
        bb_region: String,
        groups_count: usize,
        groups_minimum: usize,
    },
    BlackboxDeploymentGroupHasNoTasks {
        bb_deployment: String,
        bb_region: String,
        group_name: String,
        tasks_count: usize,
        tasks_minimum: usize,
    },
    BlackboxDeploymentGroupBoundToOtherRegion {
        bb_deployment: String,
        bb_region: String,
        group_name: String,
        group_bound_server: String,
        group_bound_server_region: String,
    },
    BlackboxDeploymentGroupBoundToMultipleServers {
        bb_deployment: String,
        bb_region: String,
        group_name: String,
        group_bound_server_a: String,
        group_bound_server_b: String,
        maximum_servers: usize,
    },
    BlackboxDeploymentStatefulGroupMustHaveCountOfOne {
        bb_deployment: String,
        bb_region: String,
        group_name: String,
        current_count: i64,
        expected_count: i64,
    },
    BlackboxDeploymentServiceRegistrationHasNotEnoughInstances {
        bb_deployment: String,
        bb_region: String,
        service_name: String,
        current_service_instances: usize,
        min_service_instances: i64,
    },
    BlackboxDeploymentPrometheusMetricsCanBeScrapedOnlyFromHttpPorts {
        bb_deployment: String,
        bb_region: String,
        service_name: String,
        group_name: String,
        group_port: i64,
        port_protocol: String,
        expected_protocol: String,
    },
    BlackboxDeploymentCantParseTaskArguments {
        bb_deployment: String,
        bb_region: String,
        group_name: String,
        task_name: String,
        task_arguments: String,
        parsing_error: String,
        example_arguments_yaml: String,
    },
    BlackboxDeploymentCantParseTaskEntrypoint {
        bb_deployment: String,
        bb_region: String,
        group_name: String,
        task_name: String,
        task_entrypoint: String,
        parsing_error: String,
        example_entrypoint_yaml: String,
    },
    BlackboxDeploymentPlacementsAreValidOnlyForStatelessWorkloads {
        bb_deployment: String,
        bb_region: String,
        group_name: String,
        group_placement: String,
        only_valid_placement: String,
        already_bound_server: String,
    },
    ApplicationInsideMultiDcRegionIsNotDistributedAcrossEnoughDatacenters {
        context: String,
        region: String,
        region_availability_mode: String,
        min_dcs: usize,
        found_dcs: usize,
        application_servers_buckets: BTreeMap<String, Vec<String>>,
    },
    ApplicationInsideMultiDcRegionIsDistributedDistributedNonEqually {
        context: String,
        region: String,
        region_availability_mode: String,
        found_dcs: usize,
        dc_with_lowest_nodes: String,
        dc_with_lowest_nodes_count: usize,
        dc_with_most_nodes: String,
        dc_with_most_nodes_count: usize,
        difference: usize,
        maximum_allowed_difference: usize,
        application_servers_buckets: BTreeMap<String, Vec<String>>,
    },
}
